<!DOCTYPE html>
<html lang="vn">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="description"
      content="Một cây nhị phân tìm kiếm (Binary Search Tree/BST) là cây nhị phân mà mỗi nút chỉ có tối đa 2 nhánh (bậc mỗi nút tối đa bằng 2) thỏa mãn tính chất của một BST: Tất cả các nút trong cây con bên trái của một nút phải giữ một giá trị khóa nhỏ hơn giá trị khóa của chính nó và tất cả các nút trong cây con bên phải của một nút phải giữ giá trị khóa lớn hơn giá trị khóa của chính nó (không có hiện tượng trùng khóa). Nút ở bên trái nhất là nút có giá trị khóa nhận diện nhỏ nhất và nút ở bên phải nhất là nút có giá trị khóa nhận diện lớn nhất. Với cây có n nút thì chi phí tìm kiếm trung bình là log2(n), độ phức tạp của thuật toán là O(log(n))"
    />
    <meta name="keywords" content="Binary Search Tree BST Hufi HUFI lazynora Nora Cây nhị phân tìm kiếm CTDL & GT Cấu trúc dữ liệu và giải thuật nhiều chức năng đếm số nút trong cây" />

    <meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
    <meta property="og:image" content="/img/png/bst.png" />
    <title>Binary Search Tree</title>
    <link rel="icon" href="/img/idiots.jpg" type="image/x-icon" />
    <link rel="shortcut icon" href="/img/idiots.jpg" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/img/idiots.jpg" />
    <link rel="apple-touch-icon" sizes="72x72" href="/img/idiots.jpg" />
    <link rel="apple-touch-icon" sizes="114x114" href="/img/idiots.jpg" />
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="/fonts/silkscreen/stylesheet.css"
    />
    <link rel="stylesheet" type="text/css" href="/css/common-1.0.0.css" />
    <link rel="stylesheet" href="/css/viz-1.0.3.css" />
    <link rel="stylesheet" href="/css/visual.css" />
    <link rel="stylesheet" href="/css/drawgraph-1.0.1.css" />
    <style>
      #rotateDeviceOverlay {
        z-index: 10000;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        background-color: white;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        overflow: hidden;
      }

      #mobile-playback-overlay {
        z-index: 9600;
        width: 90%;
        height: 100%;
        align-items: center;
        justify-content: center;
        gap: 100px;
        background-color: black;
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        display: flex;
        padding-right: 5%;
        padding-left: 5%;
        opacity: 0.3;
        overflow: hidden;
      }
      .mobile-playback-item {
        min-width: 2.5%;
        max-width: 35px;
      }
      .mobile-playback-item img {
        width: 100%;
      }
      .mobile-playback-label {
        opacity: 0;
        color: white;
        font-size: 25px;
        font-weight: bold;
        min-width: 1.5%;
        max-width: 25px;
        transition: opacity 0.25s ease-out;
        -webkit-backface-visibility: hidden;
      }
      #mobile-playback-rewind-label {
        margin-right: -70px;
      }
      #mobile-playback-forward-label {
        margin-left: -70px;
      }
      #viz-speed-value {
        font-size: 15px;
        width: 10%;
      }
    </style>
    <style>
      #insert-input input,
      #remove-input input {
        width: 100px;
      }
    </style>
    <style>
      /* copied here from common.css (perhaps need to use version numbering) until caches worldwide settles */
      #gdpr-popup,
      #reload-mobile-popup,
      #message-popup {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        min-width: 320px;
        bottom: 62px;
        height: 300px;
        background-color: #0275d8;
        border-radius: 15px;
        padding: 30px 40px;
        z-index: 9500;
      }
      #reload-mobile-popup {
        background-color: green;
        height: 200px;
      }
      #message-popup {
        z-index: 9000;
        width: 40%;
        height: 130px;
        background-color: #d9534f;
      }

      #gdpr-popup p,
      #reload-mobile-popup p,
      #message-popup p {
        font-size: large;
        color: white;
        line-height: 2;
        font-family: "PT Sans", sans-serif;
      }

      #gdpr-popup .gdpr-button,
      #reload-mobile-popup .inner-button,
      #message-popup .inner-button {
        border: white solid 2px;
        border-radius: 4px;
        font-weight: bold;
        font-size: x-large;
        padding: 2px 8px;
        color: white;
        width: 90px;
        text-align: center;
        position: absolute;
        letter-spacing: 1px;
        text-decoration: none;
        cursor: pointer;
      }

      #gdpr-accept,
      #reload-mobile-button,
      #dismiss-message-btn {
        bottom: 30px;
        right: 40px;
      }

      #gdpr-reject,
      #cancel-reload-mobile-button {
        bottom: 30px;
        right: 170px;
      }
    </style>
  </head>
  <body>
    <div
      id="body-container"
      style="display: flex; flex-direction: column; min-height: 100vh"
    >
      <style>
        #topbar {
          background-color: rgb(0, 0, 0);
          font-family: "PT Sans", sans-serif;
          font-size: 13px;
          height: 60px;

          padding-left: 40px;
          padding-right: 40px;

          display: flex;
          flex-wrap: wrap;
          align-items: center;
          position: relative;
          justify-content: flex-start;
        }

        #topbar a:hover {
          text-decoration: none;
        }
      </style>
      <nav id="topbar">
        <span style="margin-right: 0.25rem">
          <span style="max-height: 30px">
            <span id="title">
              <a id="title-BST" class="selected-viz"
                >BINARY SEARCH TREE (Cây Nhị Phân Tìm Kiếm)</a
              >
            </span>
          </span>
        </span>
        <span style="margin-left: auto;">
          <div id="Nora" class="info">
            <span class="magic">
              <span class="magic-star">
                <svg viewBox="0 0 674 674">
                  <g
                    transform="translate(0.000000,674.000000) scale(0.100000,-0.100000)"
                    stroke="none"
                  >
                    <path
                      d="M3310 6711 c-74 -23 -138 -80 -171 -156 -10 -22 -147 -558 -305
                      -1190 -158 -633 -288 -1152 -290 -1154 -2 -2 -524 -133 -1161 -293 -830 -207
                      -1171 -297 -1206 -315 -198 -109 -188 -380 18 -472 17 -8 552 -145 1190 -305
                      l1160 -291 291 -1165 c160 -641 300 -1183 312 -1206 45 -87 129 -137 232 -137
                      108 0 203 59 244 152 9 20 146 558 305 1196 l288 1160 1164 291 c640 160 1180
                      298 1199 307 19 8 50 30 68 48 145 142 86 383 -109 446 -35 11 -568 146 -1184
                      298 -616 153 -1125 283 -1131 289 -6 6 -140 528 -298 1159 -179 718 -295 1166
                      -311 1196 -30 60 -82 110 -137 133 -45 18 -125 22 -168 9z"
                    ></path>
                  </g>
                </svg>
              </span>
              <span class="magic-star">
                <svg viewBox="0 0 674 674">
                  <g
                    transform="translate(0.000000,674.000000) scale(0.100000,-0.100000)"
                    stroke="none"
                  >
                    <path
                      d="M3310 6711 c-74 -23 -138 -80 -171 -156 -10 -22 -147 -558 -305
                      -1190 -158 -633 -288 -1152 -290 -1154 -2 -2 -524 -133 -1161 -293 -830 -207
                      -1171 -297 -1206 -315 -198 -109 -188 -380 18 -472 17 -8 552 -145 1190 -305
                      l1160 -291 291 -1165 c160 -641 300 -1183 312 -1206 45 -87 129 -137 232 -137
                      108 0 203 59 244 152 9 20 146 558 305 1196 l288 1160 1164 291 c640 160 1180
                      298 1199 307 19 8 50 30 68 48 145 142 86 383 -109 446 -35 11 -568 146 -1184
                      298 -616 153 -1125 283 -1131 289 -6 6 -140 528 -298 1159 -179 718 -295 1166
                      -311 1196 -30 60 -82 110 -137 133 -45 18 -125 22 -168 9z"
                    ></path>
                  </g>
                </svg>
              </span>
              <span class="magic-star">
                <svg viewBox="0 0 674 674">
                  <g
                    transform="translate(0,674) scale(0.100000,-0.100000)"
                    stroke="none"
                  >
                    <path
                      d="M3310 6711 c-74 -23 -138 -80 -171 -156 -10 -22 -147 -558 -305
                      -1190 -158 -633 -288 -1152 -290 -1154 -2 -2 -524 -133 -1161 -293 -830 -207
                      -1171 -297 -1206 -315 -198 -109 -188 -380 18 -472 17 -8 552 -145 1190 -305
                      l1160 -291 291 -1165 c160 -641 300 -1183 312 -1206 45 -87 129 -137 232 -137
                      108 0 203 59 244 152 9 20 146 558 305 1196 l288 1160 1164 291 c640 160 1180
                      298 1199 307 19 8 50 30 68 48 145 142 86 383 -109 446 -35 11 -568 146 -1184
                      298 -616 153 -1125 283 -1131 289 -6 6 -140 528 -298 1159 -179 718 -295 1166
                      -311 1196 -30 60 -82 110 -137 133 -45 18 -125 22 -168 9z"
                    ></path>
                  </g>
                </svg>
              </span>
              <span class="magic-text">nora</span>
            </span>
            <script src="/js/animate.js"></script>
          </div>
        </span>
      </nav>
      <div id="dark-overlay"></div>
      <div id="main-content-container" style="flex: 1">
        <div id="mobile-playback-overlay" class="playing" style="display: none">
          <span id="mobile-playback-rewind-label" class="mobile-playback-label"
            >-7</span
          >
          <span
            id="mobile-playback-rewind"
            class="mobile-playback-item"
            onclick="mobilePlaybackRewind()"
            ><img src="/img/prevFrame.png" alt="rewind 7 frames"
          /></span>
          <span
            id="mobile-playback-pause"
            class="mobile-playback-item"
            onclick="mobilePlaybackPauseOrPlay()"
            ><img src="/img/pause.png" alt="pause"
          /></span>
          <span
            id="mobile-playback-play"
            class="mobile-playback-item"
            style="display: none"
            onclick="mobilePlaybackPauseOrPlay()"
            ><img src="/img/play.png" alt="play"
          /></span>
          <span
            id="mobile-playback-forward"
            class="mobile-playback-item"
            onclick="mobilePlaybackForward()"
            ><img src="/img/nextFrame.png" alt="forward 7 frames"
          /></span>
          <span id="mobile-playback-forward-label" class="mobile-playback-label"
            >+7</span
          >
        </div>
        <div id="status" class="panel"><p></p></div>
        <div id="status-hide" class="panel-hide">
          <img
            src="/img/arrow_white_right.png"
            alt=">"
            title="show/hide status panel"
          />
        </div>
        <div id="codetrace" class="panel">
          <p id="code1" style="padding-top: 10px"></p>
          <p id="code2"></p>
          <p id="code3"></p>
          <p id="code4"></p>
          <p id="code5"></p>
          <p id="code6"></p>
          <p id="code7" style="padding-bottom: 10px"></p>
        </div>
        <div id="codetrace-hide" class="panel-hide">
          <img
            src="/img/arrow_white_right.png"
            alt=">"
            title="show/hide pseudo panel"
          />
        </div>
        <div id="left-bar"></div>
        <div id="right-bar"></div>
        <div id="media-controls">
          <div id="speed-control">
            <div id="speed-input"></div>
            <div id="viz-speed-value">1x</div>
          </div>
          <span
            id="go-to-beginning"
            class="media-control-button"
            title="go to beginning"
            onclick="goToBeginning()"
            ><img src="/img/goToBeginning.png" alt="go to beginning"
          /></span>
          <span
            id="previous"
            class="media-control-button"
            title="step backward"
            onclick="stepBackward()"
            ><img src="/img/prevFrame.png" alt="previous frame"
          /></span>
          <span
            id="pause"
            class="media-control-button"
            title="pause"
            onclick="pause()"
            ><img src="/img/pause.png" alt="pause"
          /></span>
          <span
            id="play"
            class="media-control-button"
            title="play"
            onclick="play()"
            ><img src="/img/play.png" alt="play"
          /></span>
          <span
            id="next"
            class="media-control-button"
            title="step forward"
            onclick="stepForward()"
            ><img src="/img/nextFrame.png" alt="next frame"
          /></span>
          <span
            id="go-to-end"
            class="media-control-button"
            title="go to end"
            onclick="goToEnd()"
            ><img src="/img/goToEnd.png" alt="go to end"
          /></span>
          <div id="progress-bar" class="media-control-button"></div>
        </div>
        <div id="viz"></div>
        <div id="current-action" class="panel"></div>
      </div>
    </div>
    <div id="dropdown-temp-holder" hidden></div>
    <div id="rotateDeviceOverlay" style="display: none">
      <div
        id="rotateDeviceText"
        style="font-size: 50px; font-weight: bold; text-align: center"
      >
        Vui lòng xoay thiết bị của bạn sang chế độ nằm ngang để có trải nghiệm
        tốt hơn
      </div>
      <div
        id="widenDeviceText"
        style="font-size: 50px; font-weight: bold; text-align: center"
      >
        Vui lòng làm cho cửa sổ rộng hơn để có trải nghiệm tốt hơn
      </div>
    </div>

    <style>
      .create {
        bottom: 200px;
      }
    </style>
    <style>
      .search {
        bottom: 173px;
      }
    </style>
    <style>
      .insert {
        bottom: 146px;
      }
    </style>
    <style>
      .remove {
        bottom: 119px;
      }
    </style>
    <style>
      .predsucc {
        bottom: 270px;
      }
    </style>
    <style>
      .traverse {
        bottom: 65px;
      }
    </style>
    <div id="actions" class="panel">
      <p id="create">Create (Tạo)</p>
      <p id="search">Search (Tìm Kiếm)</p>
      <p id="insert">Insert (Thêm)</p>
      <p id="remove">Remove (Xóa)</p>
      <p id="predsucc">Predec-/Succ-essor (Tiền Nhiệm/Kế nhiệm)</p>
      <p id="traverse">Tree Traversal (Duyệt Cây)</p>
    </div>
    <div id="actions-hide" class="panel-hide" title="show/hide action panel">
      <span style="color: white; font-size: x-large; display: inline-block"
        >&gt;</span
      >
    </div>
    <div id="actions-extras">
      <div class="create action-menu-pullout">
        <div
          id="create-empty"
          class="execAction new-menu-option coloured-menu-option"
          onClick="empty()"
        >
          <p>Empty</p>
        </div>
        <div
          id="create-example1"
          class="execAction new-menu-option coloured-menu-option"
          onClick="example(1)"
        >
          <p>Unbalanced Example</p>
        </div>
        <div
          id="create-example2"
          class="execAction new-menu-option coloured-menu-option"
          onClick="example(2)"
        >
          <p>Balanced Example</p>
        </div>
        <div
          id="create-random"
          class="execAction new-menu-option coloured-menu-option"
          onClick="random()"
        >
          <p>Random</p>
        </div>
        <div
          id="create-skewed-left"
          class="execAction new-menu-option coloured-menu-option"
          onClick="skewed('left')"
        >
          <p>Skewed Left</p>
        </div>
        <div
          id="create-skewed-right"
          class="execAction new-menu-option coloured-menu-option"
          onClick="skewed('right')"
        >
          <p>Skewed Right</p>
        </div>
        <div id="create-err" class="err" style="float: left"></div>
      </div>
      <div class="search action-menu-pullout">
        <div
          id="find-min"
          class="execAction new-menu-option coloured-menu-option"
          onClick="findMinMax(true)"
        >
          <p>Find Minimum</p>
        </div>
        <div
          id="find-max"
          class="execAction new-menu-option coloured-menu-option"
          onClick="findMinMax(false)"
        >
          <p>Find Maximum</p>
        </div>
        <div id="search-input" class="new-menu-option">
          v =
          <input
            id="v-search"
            type="number"
            title="Nhập một số nguyên"
            autocomplete="off"
            min="0"
            max="99"
            value="7"
          />
        </div>
        <div
          id="search-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="searchVertex()"
        >
          <p>Go</p>
        </div>
        <div id="search-err" class="err" style="float: left"></div>
      </div>
      <div class="insert action-menu-pullout">
        <div id="insert-input" class="new-menu-option">
          v =
          <input
            id="v-insert"
            type="text"
            title="Nhập một số hoặc dãy số nguyên cách nhau bởi dấu phẩy"
            autocomplete="off"
            value="1,35"
          />
        </div>
        <div
          id="insert-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="insertVertex()"
        >
          <p>Go</p>
        </div>
        <div id="insert-err" class="err" style="float: left"></div>
      </div>
      <div class="remove action-menu-pullout">
        <div id="remove-input" class="new-menu-option">
          v =
          <input
            id="v-remove"
            type="text"
            title="Nhập một số hoặc dãy số nguyên cách nhau bởi dấu phẩy"
            autocomplete="off"
            value="1,35"
          />
        </div>
        <div
          id="remove-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="removeVertex()"
        >
          <p>Go</p>
        </div>
        <div id="remove-err" class="err" style="float: left"></div>
      </div>
      <div class="predsucc action-menu-pullout">
        <div id="predsucc-input" class="new-menu-option">
          v =
          <input
            id="v-predsucc"
            type="number"
            title="Nhập một số nguyên"
            autocomplete="off"
            min="0"
            max="99"
            value="15"
          />
        </div>
        <div
          id="predsucc-pred-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="predsucc(true)"
        >
          <p>Get Predecessor</p>
        </div>
        <div
          id="predsucc-succ-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="predsucc(false)"
        >
          <p>Get Successor</p>
        </div>
        <div id="predsucc-err" class="err" style="float: left"></div>
      </div>
      <div class="traverse action-menu-pullout">
        <div
          id="inorder-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="inorderTraversal()"
        >
          <p>Inorder</p>
        </div>
        <div
          id="preorder-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="preorderTraversal()"
        >
          <p>Preorder</p>
        </div>
        <div
          id="postorder-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="postorderTraversal()"
        >
          <p>Postorder</p>
        </div>
        <div id="traverse-err" class="err" style="float: left"></div>
        <div
          id="countall-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="countAll()"
        >
          <p>Count All Nodes</p>
        </div>
        <div
          id="countleaf-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="countLeaf()"
        >
          <p>Count Leaves</p>
        </div>
        <div
          id="countmedium-go"
          class="execAction new-menu-option coloured-menu-option"
          onClick="countMedium()"
        >
          <p>Count Medium Nodes</p>
        </div>
      </div>
    </div>
    <div id="bottom-bar">
      <a id="trigger-about">About</a>
    </div>
    <div id="about" class="overlays">
      <h4>About</h4>
      <span class="close-overlay">&#x2715;</span>
      <div class="content">
        <p>
          Một cây nhị phân tìm kiếm (Binary Search Tree/BST) là cây nhị phân mà
          mỗi nút chỉ có tối đa 2 nhánh (bậc mỗi nút tối đa bằng 2) thỏa mãn
          tính chất của một BST: Tất cả các nút trong cây con bên trái của một
          nút phải giữ một giá trị khóa nhỏ hơn giá trị khóa của chính nó và tất
          cả các nút trong cây con bên phải của một nút phải giữ giá trị khóa
          lớn hơn giá trị khóa của chính nó (không có hiện tượng trùng khóa).
        </p>
        <p>
          Nút ở bên trái nhất là nút có giá trị khóa nhận diện nhỏ nhất và nút ở
          bên phải nhất là nút có giá trị khóa nhận diện lớn nhất.
        </p>
        <p>
          Với cây có n nút thì chi phí tìm kiếm trung bình là log2(n), độ phức
          tạp của thuật toán là O(log(n))
        </p>
        <p><br><br><br>Visualization Demo Binary Search Tree for Team 6<br>CTDL & GT - HUFI - BST<br>Reference from <a href="https://visualgo.net">visualgo.net</a><br>Remake and update by <a href="https://github.com/lazynora">Nora</a></p>
      </div>
    </div>

    <script
      src="https://code.jquery.com/jquery-3.6.0.min.js"
      integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
      crossorigin="anonymous"
    ></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
    <script>
      $(function () {
        // overlays stuffs
        $("#trigger-about").click(function () {
          if ($(window).width() > 600) {
            $("#dark-overlay").fadeIn(function () {
              $("#about").fadeIn();
            });
          } else
            alert(
              "Xin lỗi, hộp thoại này quá lớn. Vui lòng tải nó trên màn hình lớn hơn"
            );
        });

        $(".close-overlay").click(function () {
          $(".overlays").fadeOut(function () {
            $("#dark-overlay").fadeOut();
          });
        });

        $("#dark-overlay").click(function () {
          $(".overlays").fadeOut();
          $("#dark-overlay").fadeOut();
        });
      });
    </script>
    <script>
      var colourArray = [
        "#52bc69",
        "#d65775" /*"#ed5a7d"*/,
        "#2ebbd1",
        "#d9513c",
        "#fec515",
        "#4b65ba",
        "#ff8a27",
        "#a7d41e",
      ]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() {
        $("html").css("overflow", "hidden");
      }

      function enableScroll() {
        $("html").css("overflow", "visible");
      }

      function replaceAll(find, replace, str) {
        return str.replace(new RegExp(find, "g"), replace);
      }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = Math.floor(Math.random() * colourArray.length);
          if ($.inArray(n, generatedColours) == -1) generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value >> position) & (1 === 1);
      }

      function customAlert(msg) {
        $("#custom-alert p").html(msg);
        var m = -1 * ($("#custom-alert").outerHeight() / 2);
        $("#custom-alert").css("margin-top", m + "px");
        $("#dark-overlay").fadeIn(function () {
          $("#custom-alert").fadeIn(function () {
            setTimeout(function () {
              $("#custom-alert").fadeOut(function () {
                $("#dark-overlay").fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $("#loading-overlay").show();
        $("#loading-message").show();
      }

      function hideLoadingScreen() {
        $("#loading-overlay").hide();
      }

      function commonAction(retval, msg) {
        if (retval) {
          $("#current-action").show();
          $("#current-action").html(msg);
          $("#progress-bar").slider(
            "option",
            "max",
            gw.getTotalIteration() - 1
          );
          triggerRightPanels();
          isPlaying = true;
        }
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i = 0; i < vars.length; ++i) {
          var pair = vars[i].split("=");
          //console.log(variable + " : " + pair[0] + " -> " + pair[1]);
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      const MOBILE_WIDTH = 1000;
      const matchMediaMobile = window.matchMedia(
        `only screen and (max-width: ${MOBILE_WIDTH}px)`
      );
      const matchMediaNarrow = window.matchMedia(
        `only screen and (max-width: 500px)`
      );
      function isMobile() {
        return matchMediaMobile.matches;
      }
      //To fix the issue of a narrow desktop window being asked to rotate, I am now checking for it based on the navigator.userAgent to see if its mobile or not.
      //This may change in the future if browsers decide to change the naming of userAgent for mobile browsers so may need to keep an eye on this.
      function isMobileOS() {
        return (
          /Mobi/i.test(navigator.userAgent) &&
          !/ipad/i.test(navigator.userAgent)
        );
      }
      let portraitMatcher = window.matchMedia("(orientation:portrait)");
      function isPortrait() {
        return portraitMatcher.matches;
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function () {
        $(".links").css("background", surpriseColour);
        $(".colour").css("color", surpriseColour);
        $("h4").css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $("#title a").click(function () {
          $("#title a").removeClass("selected-viz");
          $(this).addClass("selected-viz");
        });
      });

      (function (i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );
    </script>

    <script src="/js/jquery-ui.min.js"></script>

    <script src="/js/d3.min.js"></script>
    <script src="/js/viz-1.0.6.js"></script>

    <script src="/js/graph_library-1.0.8.js"></script>
    <script>
      $(function () {
        let defaultPlaybackSpeed = 1;
        createPlaybackSpeedSlider(defaultPlaybackSpeed);
        //Mobile Design Related DOM Manipulations
        if (isMobile()) {
          $("#status").css({
            bottom: "10%",
            height: "12%",
            "max-height": "54px",
          });
          $("#current-action").css("bottom", "22%");
          $("#status-hide").remove();
          $("#left-bar").remove();
          $("#right-bar").remove();
          $("#mode-menu").remove();
          $("#codetrace").css("z-index", 1);
          $("#bottom-bar a").hide();
          $("#bottom-bar").css("height", $("#topbar").css("height"));
          $(".speed-dropup-btn").show();
          $("#go-to-beginning").remove();
          $("#go-to-end").remove();
          $("#pause").remove();
          $("#play").remove();
          $("#previous").remove();
          $("#next").remove();

          //make progress bar longer
          $("#progress-bar").css({
            left: "30%",
            width: "60%",
            "margin-left": 0,
          });
        }
      });

      let mobilePlaybackOverlayTimeout;
      $(function () {
        $("#viz").on("click", () => {
          if (isMobile()) {
            if ($("#mobile-playback-overlay").is(":hidden") && isPlaying) {
              $("#mobile-playback-overlay").fadeIn();
              hideMobilePlaybackOverlay(6000);
            } else {
              $("#mobile-playback-overlay").fadeOut();
            }
          }
        });
        $("#mobile-playback-overlay").on("click", (event) => {
          if (event.target === event.currentTarget)
            //to ensure clicks on the controls dont fade the overlay
            $("#mobile-playback-overlay").fadeOut();
          else hideMobilePlaybackOverlay(5000);
        });
      });
      function hideMobilePlaybackOverlay(timeOut) {
        if (mobilePlaybackOverlayTimeout)
          clearTimeout(mobilePlaybackOverlayTimeout);
        mobilePlaybackOverlayTimeout = setTimeout(() => {
          $("#mobile-playback-overlay").fadeOut();
        }, timeOut);
      }
      function mobilePlaybackPauseOrPlay() {
        if ($("#mobile-playback-overlay").hasClass("playing")) {
          pause();
          hideMobilePlaybackOverlay(5000);
        } else {
          play();
          hideMobilePlaybackOverlay(3000);
        }
      }
      let rewindLabelTimeout, forwardLabelTimeout;
      function mobilePlaybackRewind() {
        $("#mobile-playback-rewind-label").css("opacity", 1);
        if (rewindLabelTimeout) clearTimeout(rewindLabelTimeout);
        rewindLabelTimeout = setTimeout(() => {
          $("#mobile-playback-rewind-label").css("opacity", 0);
        }, 800);
        stepBackward(7);
      }
      function mobilePlaybackForward() {
        $("#mobile-playback-forward-label").css("opacity", 1);
        if (forwardLabelTimeout) clearTimeout(forwardLabelTimeout);
        forwardLabelTimeout = setTimeout(() => {
          $("#mobile-playback-forward-label").css("opacity", 0);
        }, 800);
        stepForward(7);
      }

      //let eLectureSessionHistory = {};
      const sectorColors = ["#05a4d0", "#f1c706", "#fa0202"];

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
          sURLVariables = sPageURL.split("&"),
          sParameterName,
          i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split("=");
          if (sParameterName[0] === sParam)
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      }

      function showPopup(callback) {
        $("#popup").fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $("#popup").fadeOut(100, callback);
      }

      function sectorBasedModeSelection() {
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());
        //check params are empty and then that all sectors are completed or not
        if (
          !Object.keys(params).length &&
          sector1Count === sectorLength &&
          sector2Count === sectorLength &&
          sector3Count === numSlides - 2 * sectorLength
        ) {
          hideOverlay();
        } else $("#mode-menu a").click();
      }

      $(function () {
        if (isMobileOS() && portraitMatcher.matches) {
          $("#rotateDeviceOverlay").show();
          $("#rotateDeviceText").show();
          $("#widenDeviceText").hide();
          $("#topbar").css("z-index", 10001);
        } else if (matchMediaNarrow.matches) {
          $("#rotateDeviceOverlay").show();
          $("#rotateDeviceText").hide();
          $("#widenDeviceText").show();
          $("#topbar").css("z-index", 10001);
        } else {
          $("#rotateDeviceOverlay").hide();
          $("#topbar").css("z-index", "");
        }

        matchMediaNarrow.addEventListener("change", (e) => {
          //screws up for square device! NEED RESIZE EVENT
          if (e.matches) {
            if ($("#rotateDeviceOverlay").is(":hidden")) {
              $("#rotateDeviceOverlay").show();
              $("#rotateDeviceText").hide();
              $("#widenDeviceText").show();
              $("#topbar").css("z-index", 10001);
            }
          } else {
            $("#rotateDeviceOverlay").hide();
            $("#topbar").css("z-index", "");
          }
        });
        portraitMatcher.addEventListener("change", (e) => {
          if (e.matches && isMobileOS()) {
            if ($("#rotateDeviceOverlay").is(":hidden")) {
              $("#rotateDeviceOverlay").show();
              $("#rotateDeviceText").show();
              $("#widenDeviceText").hide();
              $("#topbar").css("z-index", 10001);
            }
          } else {
            $("#rotateDeviceOverlay").hide();
            $("#topbar").css("z-index", "");
          }
        });
        const urlSearchParams = new URLSearchParams(window.location.search);
        const params = Object.fromEntries(urlSearchParams.entries());

        $("#hide-popup").click(function () {
          hidePopup();
        });

        $("#popup").hover(
          function () {
            $("#hide-popup").show();
          },
          function () {
            $("#hide-popup").hide();
          }
        );
      });

      function adjustPopupToImageSize() {
        var width = $("#popup-image").prop("width");
        var height = $("#popup-image").prop("height");
        $("#popup").width(width + 20);
        $("#popup").height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();
        }
      }

      function POPUP_IMAGE(url) {
        $("#popup-content").html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url) {
        window.open(url, "_blank");
      }

      $(document).ready(function () {
        setTimeout(function () {
          $("#change-lang-popup").fadeOut("slow");
        }, 5000);
      });
    </script>
    <script type="text/javascript">
      var extraCSS = {
        traverse: "65px",
        predsucc: "92px",
        remove: "119px",
        insert: "146px",
        search: "173px",
        create: "200px",
      };
      var actionsIds = {
        create: { p: "Create" },
        search: { p: "Search" },
        insert: { p: "Insert" },
        remove: { p: "Remove" },
        predsucc: { p: "Predec-\/Succ-essor" },
        traverse: { p: "Tree Traversal" },
      };
      var isOpens = {};
      var len = 6;
      var keys = [
        "create",
        "search",
        "insert",
        "remove",
        "predsucc",
        "traverse",
      ];
      for (i = 0; i < len; i++) {
        var actionDetails = keys[i];
        isOpens[actionDetails] = false;
      }
      function openAction(id) {
        hideThirdTiers(id);
        $("." + id).css("bottom", extraCSS[id]);
        if (!isOpens[id]) {
          $("." + id).fadeIn("fast");
          isOpens[id] = true;
        }
      }
      function closeAction(id) {
        hideThirdTiers(id);
        if (isOpens[id]) {
          $("." + id).fadeOut("fast");
          $("#" + id + "-err").html("");
          isOpens[id] = false;
        }
      }

      function hideEntireActionsPanel() {
        //hideAllThirdTiers();
        closeAction("create");
        closeAction("search");
        closeAction("insert");
        closeAction("remove");
        closeAction("predsucc");
        closeAction("traverse");
        hideActionsPanel();
      }

      function hideThirdTiers(tier1Action) {
        if ("parents" in actionsIds[tier1Action]) {
          for (const secondTierAction of actionsIds[tier1Action]["parents"]) {
            $("#" + secondTierAction + "-third-tier").fadeOut("fast");
          }
        }
      }

      function hideAllThirdTiers() {
        for (const tier1Action in actionsIds) {
          hideThirdTiers(tier1Action);
        }
      }

      function toggleChildExtras(tier1, selectedParentTier2) {
        hideThirdTiers(tier1);
        //this actionId must have childExtras
        var style = extraCSS[tier1];
        $("." + tier1).css(
          "bottom",
          parseInt(style.substring(0, style.length - 2)) - 27
        );
        //fade ins and outs are done on the ID whereas css class is set on the class
        //fade in the third tier of the selected 2nd tier parent
        $("#" + selectedParentTier2 + "-third-tier").fadeIn("fast");

        // //fade out all other third tiers of that 'action'
        // for (const parent of actions[tier1]["parents"]) {
        //     console.log("parent is " + parent + " for " + selectedParentTier2);
        //     if (parent != selectedParentTier2) {
        //         $('#' + parent + '-third-tier').fadeOut('fast');
        //     }
        // }
      }

      function setActionHeightOriginal(tier1Action) {
        $("." + tier1Action).css("bottom", extraCSS[tier1Action]);
      }

      $("#" + "create").click(function () {
        openAction("create");
        closeAction("search");
        closeAction("insert");
        closeAction("remove");
        closeAction("predsucc");
        closeAction("traverse");
      });
      $("#" + "search").click(function () {
        openAction("search");
        closeAction("create");
        closeAction("insert");
        closeAction("remove");
        closeAction("predsucc");
        closeAction("traverse");
      });
      $("#" + "insert").click(function () {
        openAction("insert");
        closeAction("create");
        closeAction("search");
        closeAction("remove");
        closeAction("predsucc");
        closeAction("traverse");
      });
      $("#" + "remove").click(function () {
        openAction("remove");
        closeAction("create");
        closeAction("search");
        closeAction("insert");
        closeAction("predsucc");
        closeAction("traverse");
      });
      $("#" + "predsucc").click(function () {
        openAction("predsucc");
        closeAction("create");
        closeAction("search");
        closeAction("insert");
        closeAction("remove");
        closeAction("traverse");
      });
      $("#" + "traverse").click(function () {
        openAction("traverse");
        closeAction("create");
        closeAction("search");
        closeAction("insert");
        closeAction("remove");
        closeAction("predsucc");
      });

      //important to have all the input fields in actions menu take an id containing '-input'
      $("[id*='-input']").on("keypress keydown keyup", (event) => {
        event.stopPropagation();
      });
    </script>
    <script type="text/javascript">
      var BST = function () {
        var self = this;
        var gw = new GraphWidget();

        var valueRange = [-999, 999]; // Range of valid values of BST vertexes allowed
        var maxHeightAllowed = 9; // max 9 edges (10 vertices)

        var initialArray = [14, 6, 23, 4, 7, 71, 5, 51];
        /*
         * iBST: Internal representation of BST in this object
         * The keys are the text of the nodes, and the value is the attributes of the corresponding node encapsulated in a JS object, which are:
         * - "parent": text of the parent node. If the node is root node, the value is null.
         * - "leftChild": text of the left child. No child -> null
         * - "rightChild": text of the right child. No child -> null
         * - "cx": X-coordinate of center of the node
         * - "cy": Y-coordinate of center of the node
         * - "height": height of the node. Height of root is 0
         * - "vertexClassNumber": Vertex class number of the corresponding node
         *
         * In addition, there is a key called "root" in iBST, containing the text of the root node.
         * If BST is empty, root is null.
         */

        var iBST = {};
        var amountVertex = 0;
        iBST["root"] = null;

        init(initialArray);

        this.getGraphWidget = function () {
          return gw;
        };

        function dummyInit() {
          iBST["root"] = 15;
          iBST[15] = {
            parent: null,
            leftChild: 6,
            rightChild: 23,
            vertexClassNumber: 0,
          };
          iBST[6] = {
            parent: 15,
            leftChild: 4,
            rightChild: 7,
            vertexClassNumber: 1,
          };
          iBST[23] = {
            parent: 15,
            leftChild: null,
            rightChild: 71,
            vertexClassNumber: 2,
          };
          iBST[4] = {
            parent: 6,
            leftChild: null,
            rightChild: 5,
            vertexClassNumber: 3,
          };
          iBST[7] = {
            parent: 6,
            leftChild: null,
            rightChild: null,
            vertexClassNumber: 4,
          };
          iBST[71] = {
            parent: 23,
            leftChild: 50,
            rightChild: null,
            vertexClassNumber: 5,
          };
          iBST[5] = {
            parent: 4,
            leftChild: null,
            rightChild: null,
            vertexClassNumber: 6,
          };
          iBST[50] = {
            parent: 71,
            leftChild: null,
            rightChild: null,
            vertexClassNumber: 7,
          };

          var key;
          recalculatePosition();

          for (key in iBST) {
            if (key == "root") continue;

            var cur = iBST[key];
            gw.addVertex(
              cur["cx"],
              cur["cy"],
              key,
              cur["vertexClassNumber"],
              true
            );
          }

          for (key in iBST) {
            if (key == "root") continue;

            var cur = iBST[key];
            var parentVertex = iBST[cur["parent"]];
            if (cur["parent"] == null) continue;

            gw.addEdge(
              parentVertex["vertexClassNumber"],
              cur["vertexClassNumber"],
              cur["vertexClassNumber"],
              EDGE_TYPE_UDE,
              1,
              true
            );
          }

          amountVertex = 8;
        }

        this.generate = function (array) {
          init(array);
        };

        this.generateEmpty = function () {
          var vertexAmt = 0;
          var initArr = [];
          init(initArr);
          return true;
        };

        this.generateExample = function (id) {
          var vertexAmt = 8; // for id == 1
          var initArr = [15, 6, 23, 4, 7, 71, 5, 50];
          if (id == 2) {
            vertexAmt = 10;
            initArr = [41, 20, 65, 11, 29, 50, 91, 32, 72, 99];
          } else if (id == 3) {
            vertexAmt = 15;
            initArr = [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15];
          } else if (id == 4) {
            vertexAmt = 12;
            initArr = [8, 6, 16, 3, 7, 13, 19, 2, 11, 15, 18, 10];
          } else if (id == 5) {
            vertexAmt = 20;
            initArr = [
              13, 8, 18, 5, 11, 16, 20, 3, 7, 10, 12, 15, 17, 19, 2, 4, 6, 9,
              14, 1,
            ];
          }
          init(initArr);
          return true;
        };

        this.generateRandom = function () {
          var vertexAmt = Math.floor(Math.random() * 7 + 10); // [10..16]
          var initArr = [];

          while (initArr.length < vertexAmt) {
            var random = Math.floor(1 + Math.random() * 99); // [1..99]
            if ($.inArray(random, initArr) < 0)
              // distinct
              initArr.push(random);
          }
          // from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
          function shuffle(array) {
            let currentIndex = array.length,
              randomIndex;
            // while there remain elements to shuffle...
            while (currentIndex != 0) {
              // pick a remaining element...
              randomIndex = Math.floor(Math.random() * currentIndex);
              --currentIndex;
              // and swap it with the current element.
              [array[currentIndex], array[randomIndex]] = [
                array[randomIndex],
                array[currentIndex],
              ];
            }
            return array;
          }

          shuffle(initArr);
          init(initArr);

          return true;
        };

        this.generateSkewed = function (side) {
          var vertexAmt = Math.floor(5 + Math.random() * 5); // [5..9] vertices (allow +1 for one more right/left extreme insertion)
          var initArr = new Array();
          while (initArr.length < vertexAmt) {
            var random = Math.floor(1 + Math.random() * 99); // value [1..99]
            if ($.inArray(random, initArr) < 0) initArr.push(random);
          }
          if (side == "left") {
            initArr.sort(function (a, b) {
              return b - a;
            });
          } else if (side == "right") {
            initArr.sort(function (a, b) {
              return a - b;
            });
          }
          init(initArr);
          return true;
        };

        this.getRandomInBST = function () {
          var arr = new Array();
          for (var key in iBST) {
            if (key == "root") continue;
            arr.push(key);
          }
          return parseInt(arr[Math.floor(Math.random() * arr.length)]);
        };

        this.getRandomNotInBST = function () {
          var arr = new Array();
          for (var key in iBST) {
            if (key == "root") continue;
            arr.push(parseInt(key));
          }
          var candidate = 1 + Math.floor(Math.random() * 99); // [1..99]
          while ($.inArray(candidate, arr) > 0)
            candidate = 1 + Math.floor(Math.random() * 99);
          return candidate;
        };

        this.search = function (val, callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            currentVertexClass,
            key,
            ans;

          cs = createState(iBST);
          cs["status"] = "Cây BST (root)."; //status_search_0
          cs["lineNo"] = 0;
          sl.push(cs);

          while (cur != val && cur != null) {
            cs = createState(iBST, vertexTraversed, edgeTraversed);
            currentVertexClass = iBST[cur]["vertexClassNumber"];
            cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
            vertexTraversed[cur] = true;
            //status_search_1
            cs["status"] = "So sánh {cur} với {val}."
              .replace("{cur}", cur)
              .replace("{val}", val);
            cs["lineNo"] = 3;
            sl.push(cs);

            if (parseInt(val) > parseInt(cur)) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              //status_search_2
              cs["status"] = "{cur} nhỏ hơn {val}."
                .replace("{cur}", cur)
                .replace("{val}", val);
              cs["lineNo"] = 5;
              sl.push(cs);

              cur = iBST[cur]["rightChild"];
              if (cur == null) {
                cs = createState(iBST, vertexTraversed, edgeTraversed);
                //status_search_3
                cs["status"] = "Giá trị {val} không có trong BST.".replace(
                  "{val}",
                  val
                );
                cs["lineNo"] = [1, 2];
                sl.push(cs);
                break;
              }

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              var edgeHighlighted = iBST[cur]["vertexClassNumber"];
              edgeTraversed[edgeHighlighted] = true;
              cs["el"][edgeHighlighted]["animateHighlighted"] = true;
              cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
              //status_search_4
              cs["status"] = "Chuyển qua tìm bên nhánh phải.";
              cs["lineNo"] = 6;
              sl.push(cs);
            } else {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              //status_search_5
              cs["status"] = "{cur} lớn hơn {val}."
                .replace("{cur}", cur)
                .replace("{val}", val);
              cs["lineNo"] = 7;
              sl.push(cs);

              cur = iBST[cur]["leftChild"];
              if (cur == null) {
                cs = createState(iBST, vertexTraversed, edgeTraversed);
                //status_search_6
                cs["status"] = "Giá trị {val} không có trong BST.".replace(
                  "{val}",
                  val
                );
                cs["lineNo"] = [1, 2];
                sl.push(cs);
                break;
              }

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              var edgeHighlighted = iBST[cur]["vertexClassNumber"];
              edgeTraversed[edgeHighlighted] = true;
              cs["el"][edgeHighlighted]["animateHighlighted"] = true;
              cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
              //status_search_7
              cs["status"] = "Chuyển qua tìm bên nhánh trái.";
              cs["lineNo"] = 7;
              sl.push(cs);
            }
          }

          if (cur != null) {
            cs = createState(iBST, vertexTraversed, edgeTraversed);
            currentVertexClass = iBST[cur]["vertexClassNumber"];
            cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][currentVertexClass]["extratext"] = "v";
            //status_search_8
            cs["status"] = "Đã tìm thấy giá trị {val}.".replace("{val}", val);
            cs["lineNo"] = 4;
            sl.push(cs);
          }

          gw.startAnimation(sl, callback);
          populatePseudocode(4);
          return true;
        };

        this.findMax = function () {
          var ans = -1;
          for (key in iBST) {
            if (key == "root") continue;
            ans = Math.max(ans, key);
          }
          return ans;
        };

        this.findMinMax = function (isMin, callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key,
            ans;

          cs = createState(iBST);
          //status_minmax_0
          cs["status"] = "Cây BST (root).";
          cs["lineNo"] = 0;
          sl.push(cs);

          if (cur == null) {
            cs = createState(iBST);
            if (isMin) {
              //status_minmax_1
              cs["status"] = "Cây rỗng, không có giá trị nhỏ nhất.";
            } else {
              //status_minmax_2
              cs["status"] = "Cây rỗng, không có giá trị lớn nhất.";
            }
            cs["lineNo"] = 1;
            sl.push(cs);
            gw.startAnimation(sl, callback);
            return true;
          }

          while (cur != null) {
            cs = createState(iBST, vertexTraversed, edgeTraversed);
            key = iBST[cur]["vertexClassNumber"];
            cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            vertexTraversed[cur] = true;
            if (
              (isMin && iBST[cur]["leftChild"] != null) ||
              (!isMin && iBST[cur]["rightChild"] != null)
            ) {
              if (isMin) {
                //cs["status"] = cur + " is not the minimum value as it has a left child.";  //status_minmax_3
                cs["status"] =
                  "{cur} không phải giá trị nhỏ nhất vì nó có nhánh trái.".replace(
                    "{cur}",
                    cur
                  );
              } else {
                //cs["status"] = cur + " is not the maximum value as it has a right child.";  //status_minmax_4
                cs["status"] =
                  "{cur} không phải giá trị lớn nhất vì nó có nhánh phải.".replace(
                    "{cur}",
                    cur
                  );
              }
              cs["lineNo"] = 2;
            } else {
              ans = cur;
              if (isMin) {
                //cs["status"] = "Minimum value found!";  //status_minmax_5
                cs["status"] = "Đã tìm thấy Min!";
                cs["vl"][key]["extratext"] = "Min";
              } else {
                //cs["status"] = "Maximum value found!";  //status_minmax_6
                cs["status"] = "Đã tìm thấy Max!";
                cs["vl"][key]["extratext"] = "Max";
              }

              cs["lineNo"] = 4;
            }
            cur = isMin ? iBST[cur]["leftChild"] : iBST[cur]["rightChild"];
            sl.push(cs);

            if (cur == null) break;

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            var edgeHighlighted = iBST[cur]["vertexClassNumber"];
            edgeTraversed[edgeHighlighted] = true;
            cs["el"][edgeHighlighted]["animateHighlighted"] = true;
            cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
            if (isMin) {
              //cs["status"] = "Go left to check for smaller value..."; //status_minmax_7
              cs["status"] =
                "Chuyển qua nhánh trái để kiểm tra giá trị nhỏ hơn...";
            } else {
              //cs["status"] = "Go right to check for larger value..."; //status_minmax_8
              cs["status"] =
                "Chuyển qua nhánh phải để kiểm tra giá trị lớn hơn...";
            }

            cs["lineNo"] = 3;
            sl.push(cs);
          }

          populatePseudocode(isMin ? 2 : 1);
          gw.startAnimation(sl, callback);
          return true;
        };

        this.findPredSucc = function (val, isPred, callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key,
            currentVertexClass;
          cur = val = parseInt(val);

          if (val == null || val == undefined || isNaN(val)) {
            $("#predsucc-err").html("Hãy điền giá trị hợp lệ!");
            return false;
            invalidval;
          }

          if (iBST[val] == null) {
            $("#predsucc-err").html("Hãy điền một giá trị đã có trong BST!");
            return false;
          }

          key = iBST[val]["vertexClassNumber"];
          cs = createState(iBST);
          //status_predsucc_0
          cs["status"] = "Cây BST (root).";
          cs["lineNo"] = 0;
          sl.push(cs);

          if (
            (isPred && iBST[val]["leftChild"] != null) ||
            (!isPred && iBST[val]["rightChild"] != null)
          ) {
            var subTreeRoot = isPred
              ? iBST[val]["leftChild"]
              : iBST[val]["rightChild"];
            var subTreeRootKey = iBST[subTreeRoot]["vertexClassNumber"];

            edgeTraversed[subTreeRootKey] = true;

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            cs["el"][subTreeRootKey]["animateHighlighted"] = true;
            if (isPred) {
              //cs["status"] = "This vertex has a left child, so go left.";  //status_predsucc_1
              cs["status"] = "Nút này có nhánh trái, chuyển sang trái.";
            } else {
              //cs["status"] = "This vertex has a right child, so go right.";  //status_predsucc_2
              cs["status"] = "Nút này có nhánh phải, chuyển sang phải.";
            }

            cs["lineNo"] = 1;
            sl.push(cs);

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
            if (isPred) {
              //cs["status"] = "Check whether the left child has a right child."; //status_predsucc_3
              cs["status"] = "Kiểm tra nếu nhánh trái có nhánh phải.";
            } else {
              //cs["status"] = "Check whether the right child has a left child."; //status_predsucc_4
              cs["status"] = "Kiểm tra nếu nhánh phải có nhánh trái.";
            }
            cs["lineNo"] = 1;
            sl.push(cs);

            if (
              (isPred && iBST[subTreeRoot]["rightChild"] != null) ||
              (!isPred && iBST[subTreeRoot]["leftChild"] != null)
            ) {
              cur = subTreeRoot;
              currentVertexClass = iBST[cur]["vertexClassNumber"];

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
              if (isPred) {
                //status_predsucc_5
                cs["status"] = "Tìm thấy nhánh phải! Chuyển sang bên phải.";
              } else {
                //status_predsucc_6
                cs["status"] = "Tìm thấy nhánh trái! Chuyển ang bên trái.";
              }
              cs["lineNo"] = 1;
              sl.push(cs);

              while (
                (isPred && iBST[cur]["rightChild"] != null) ||
                (!isPred && iBST[cur]["leftChild"] != null)
              ) {
                cs = createState(iBST, vertexTraversed, edgeTraversed);
                cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
                vertexTraversed[cur] = true;
                if (isPred) {
                  //status_predsucc_7
                  cs["status"] =
                    "{cur} không phải là nút tiền nhiệm vì nó có nhánh phải.".replace(
                      "{cur}",
                      cur
                    );
                } else {
                  //status_predsucc_8
                  cs["status"] =
                    "{cur} không phải là nút kế tiếp vì nó có nhánh trái.".replace(
                      "{cur}",
                      cur
                    );
                }
                cs["lineNo"] = 1;
                sl.push(cs);

                cur = isPred ? iBST[cur]["rightChild"] : iBST[cur]["leftChild"];
                currentVertexClass = iBST[cur]["vertexClassNumber"];

                cs = createState(iBST, vertexTraversed, edgeTraversed);
                var edgeHighlighted = currentVertexClass;
                edgeTraversed[edgeHighlighted] = true;
                cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
                cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
                if (isPred) {
                  //status_predsucc_9
                  cs["status"] =
                    "Chuyển qua nhánh phải để kiểm tra giá trị lớn hơn.";
                } else {
                  //status_predsucc_10
                  cs["status"] =
                    "Chuyển qua nhánh trái để kiểm tra giá trị nhỏ hơn.";
                }
                cs["lineNo"] = 1;
                sl.push(cs);
              }

              ans = cur;

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
              if (isPred) {
                //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_11
                cs["status"] =
                  "Tìm thấy nút tiền nhiệm!<br>Nút tiền nhiệm của {val} là {ans}."
                    .replace("{ans}", ans)
                    .replace("{val}", val);
              } else {
                //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_12
                cs["status"] =
                  "Tìm thấy nút kế nhiệm!<br>Nút kế nhiệm của {val} là {ans}."
                    .replace("{ans}", ans)
                    .replace("{val}", val);
              }
              cs["vl"][key]["extratext"] = "v";
              cs["vl"][currentVertexClass]["extratext"] =
                (isPred ? "predecessor" : "successor") + " of v";
              cs["lineNo"] = 1;
              sl.push(cs);
            } else {
              ans = subTreeRoot;

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
              if (isPred) {
                //cs["status"] = "No right child found, so this vertex is the predecessor.<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_13
                cs["status"] =
                  "Không tìm thấy nhánh phải, vì thế nút này là nút tiền nhiệm.<br>Nút tiền nhiệm của {val} là {ans}."
                    .replace("{ans}", ans)
                    .replace("{val}", val);
              } else {
                //cs["status"] = "No left child found, so this vertex is the successor.<br>The successor of " + val + " is " + ans + "."; //status_predsucc_14
                cs["status"] =
                  "Không tìm thấy nhánh trái, vì thế nút này là nút kế nhiệm.<br>Nút kế nhiệm của {val} lầ {ans}."
                    .replace("{ans}", ans)
                    .replace("{val}", val);
              }
              cs["vl"][key]["extratext"] = "v";
              cs["vl"][subTreeRootKey]["extratext"] =
                (isPred ? "predecessor" : "successor") + " of v";
              cs["lineNo"] = 1;
              sl.push(cs);
            }
          } else {
            currentVertexClass = iBST[cur]["vertexClassNumber"];

            edgeTraversed[currentVertexClass] = true;

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            cs["el"][currentVertexClass]["state"] = EDGE_HIGHLIGHTED;
            if (isPred) {
              //cs["status"] = "No left child found, so check the parent..";  //status_predsucc_15
              cs["status"] =
                "Không tìm thấy nút con trái, vì vậy kiểm tra nút cha..";
            } else {
              //cs["status"] = "No right child found, so check the parent.."; //status_predsucc_16
              cs["status"] =
                "Khong tìm thấy nút con phải, vì vậy kiểm tra nút cha..";
            }
            cs["lineNo"] = [2, 3];
            sl.push(cs);

            cur = iBST[cur]["parent"];
            currentVertexClass = iBST[cur]["vertexClassNumber"];

            while (true) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
              vertexTraversed[cur] = true;
              if ((isPred && cur > val) || (!isPred && cur < val)) {
                if (isPred) {
                  //cs["status"] = cur + " is not the predecessor vertex as " + val + " is part of the left sub-tree";  //status_predsucc_17
                  cs["status"] =
                    "{cur} không phải là nút tiền nhiệm vì {val} là một phần của cây con bên trái"
                      .replace("{cur}", cur)
                      .replace("{val}", val);
                } else {
                  //cs["status"] = cur + " is not the successor vertex as " + val + " is part of the right sub-tree"; //status_predsucc_18
                  cs["status"] =
                    "{cur} không phải là nút kế nhiệm vì {val} là một phần của cây con bên phải"
                      .replace("{cur}", cur)
                      .replace("{val}", val);
                }
                cs["lineNo"] = 4;
                sl.push(cs);
              } else {
                ans = cur;
                if (isPred) {
                  //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_19
                  cs["status"] =
                    "Tìm thấy nút tiền nhiệm!<br>Nút tiền nhiệm của {val} là {ans}."
                      .replace("{ans}", ans)
                      .replace("{val}", val);
                } else {
                  //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_20
                  cs["status"] =
                    "Tìm thấy nút kế nhiệm!<br>Nút kế nhiệm của {val} là {ans}."
                      .replace("{ans}", ans)
                      .replace("{val}", val);
                }
                cs["vl"][key]["extratext"] = "v";
                cs["vl"][currentVertexClass]["extratext"] =
                  (isPred ? "predecessor" : "successor") + " of v";
                cs["lineNo"] = 7;
                sl.push(cs);
                break;
              }

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              var edgeHighlighted = currentVertexClass;
              if (cur != iBST["root"]) edgeTraversed[edgeHighlighted] = true;
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              if (cur != iBST["root"])
                cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Go up to check for smaller value."; //status_predsucc_21
              cs["status"] = "Đi lên để kiểm tra giá trị nhỏ hơn.";
              cs["lineNo"] = 5;
              sl.push(cs);

              cur = iBST[cur]["parent"];
              if (cur == null) break;

              currentVertexClass = iBST[cur]["vertexClassNumber"];
            }

            if (cur == null) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
              if (isPred) {
                //cs["status"] = "Parent is null, so " + val + " has no predecessor.";  //status_predsucc_22
                cs["status"] =
                  "Nút cha không tồn tại, vì vậy {val} không có nút tiền nhiệm.".replace(
                    "{val}",
                    val
                  );
              } else {
                //cs["status"] = "Parent is null, so " + val + " has no successor.";  //status_predsucc_23
                cs["status"] =
                  "Nút cha không tồn tại, vì vậy {val} không có nút kế nhiệm.".replace(
                    "{val}",
                    val
                  );
              }
              cs["lineNo"] = 6;
              sl.push(cs);

              ans = null;
            }
          }

          gw.startAnimation(sl, callback);
          populatePseudocode(isPred ? 9 : 8);
          return true;
        };

        this.inorderTraversal = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          //cs["status"] = "The current BST.";  //status_inorder_0
          cs["status"] = "Cây BST (root).";
          cs["lineNo"] = 0;
          sl.push(cs);

          var in_list = "";

          if (iBST["root"] == null) {
            cs = createState(iBST);
            //cs["status"] = "The Binary Search Tree is empty.<br>Return empty result.";  //status_inorder_1
            cs["status"] = "Cây BST rỗng.<br>Trả về giá trị rỗng.";
            cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            //cs["status"] = "The root " + iBST["root"] + " is not null.";  //status_inorder_2
            cs["status"] = "Gốc {root} không phải là giá trị rỗng.".replace(
              "{root}",
              iBST["root"]
            );
            cs["lineNo"] = 1;
            sl.push(cs);

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            //cs["status"] = "So recurse and check left child of " + iBST["root"] + ".";  //status_inorder_3
            cs["status"] =
              "Vì vậy đệ quy và kiểm tra nút con bên trái của {root}.".replace(
                "{root}",
                iBST["root"]
              );
            cs["lineNo"] = 3;
            sl.push(cs);

            inorderTraversalRecursion(iBST["root"]);
          }

          cs = createState(iBST, vertexTraversed, edgeTraversed);
          inorderHighlightVertex(key);
          cs["status"] =
            "Quá trình duyệt theo thứ tự (In-order) của toàn bộ BST đã hoàn tất.<br>Kết quả: " +
            in_list.slice(0, -1); //status_inorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function inorderTraversalRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            if (curLeft == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              inorderHighlightVertex(key);
              //cs["status"] = "The left child of vertex with value " + cur + " is empty.<br>Return empty.";  //status_inorder_5
              cs["status"] =
                "Giá trị của nút con bên trái của nút {cur} rỗng.<br>Trả về rỗng.".replace(
                  "{cur}",
                  cur
                );
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curLeftClass = iBST[curLeft]["vertexClassNumber"];

              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              inorderHighlightVertex(key);
              //cs["status"] = "The left child of vertex with value " + cur + " is " + curLeft + " (not null).";  //status_inorder_6
              cs["status"] =
                "Giá trị của nút con bên trái của nút {cur} là {curLeft} (khác rỗng)."
                  .replace("{cur}", cur)
                  .replace("{curLeft}", curLeft);
              cs["lineNo"] = 3;
              sl.push(cs);
              edgeTraversed[curLeftClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curLeftClass]["animateHighlighted"] = true;
              inorderHighlightVertex(key);
              //cs["status"] = "So recurse and check left child of vertex with value " + curLeft + ".";//status_inorder_7
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên trái của nút {curLeft}.".replace(
                  "{curLeft}",
                  curLeft
                );
              cs["lineNo"] = 3;
              sl.push(cs);
              inorderTraversalRecursion(curLeft);
            }

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            vertexHighlighted[key] = true;
            inorderHighlightVertex(key);
            in_list = in_list + cur + ",";
            cs["status"] =
              "Gặp nút " +
              cur +
              "  và chuẩn bị để chuyển sang nhánh con bên phải.<br>In-order: " +
              in_list +
              "..."; //status_inorder_8
            //cs["status"] = 'Visit vertex with value {cur}.<br>And preparing to visit the right child of this vertex.'.replace("{cur}", cur);
            cs["lineNo"] = 4;
            sl.push(cs);

            if (curRight == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              inorderHighlightVertex(key);
              //cs["status"] = "The right child of vertex with value " + cur + " is empty.<br>Return empty.<br>"; //status_inorder_9
              cs["status"] =
                "Giá trị của nút con bên phải của nút {cur} là rỗng.<br>Trả về rỗng.<br>".replace(
                  "{cur}",
                  cur
                );
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curRightClass = iBST[curRight]["vertexClassNumber"];

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              inorderHighlightVertex(key);
              //cs["status"] = "The right child of vertex with value " + cur + " is " + curRight + " (not null).";  //status_inorder_10
              cs["status"] =
                "Giá trị của nút con bên phải của nút {cur} là {curRight} (khác rỗng)."
                  .replace("{cur}", cur)
                  .replace("{curRight}", curRight);
              cs["lineNo"] = 4;
              sl.push(cs);
              edgeTraversed[curRightClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curRightClass]["animateHighlighted"] = true;
              inorderHighlightVertex(key);
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên phải của nút {curRight}.".replace(
                  "{curRight}",
                  curRight
                );
              cs["lineNo"] = 5;
              sl.push(cs);
              inorderTraversalRecursion(curRight);
            }

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            if (cur != iBST["root"]) cs["el"][key]["state"] = EDGE_HIGHLIGHTED;
            inorderHighlightVertex(key);

            //cs["status"] = "In-order traversal of " + cur + " is complete.";  //status_inorder_12
            cs["status"] = "Duyệt theo In-order của {cur} đã hoàn tất.".replace(
              "{cur}",
              cur
            );
            cs["lineNo"] = 0;
            sl.push(cs);
          }

          function inorderHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(3);
          return true;
        };

        this.preorderTraversal = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          cs["status"] = "Cây BST hiện tại (root)."; //'The current BST.';
          cs["lineNo"] = 0;
          sl.push(cs);

          var pre_list = "";

          if (iBST["root"] == null) {
            cs = createState(iBST);
            cs["status"] = "Cây BST rỗng.<br>Trả về giá trị rỗng."; //status_preorder_1
            //cs["status"] = 'The Binary Search Tree is empty.<br>Return empty result.';
            cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            cs["status"] =
              "Gốc " + iBST["root"] + " không phải là giá trị rỗng."; //status_preorder_2
            //cs["status"] = 'The root {root} is not null.'.replace("{root}", iBST["root"]);
            cs["lineNo"] = 1;
            sl.push(cs);

            preorderTraversalRecursion(iBST["root"]);
          }

          cs = createState(iBST, vertexTraversed, edgeTraversed);
          preorderHighlightVertex(key);
          cs["status"] =
            "Quá trình duyệt theo Pre-order của toàn bộ BST đã hoàn tất.<br>Kết quả: " +
            pre_list.slice(0, -1); //status_preorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function preorderTraversalRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            vertexHighlighted[key] = true;
            preorderHighlightVertex(key);
            pre_list = pre_list + cur + ",";
            cs["status"] =
              "Gặp nút " +
              cur +
              " và chuẩn bị chuyển sang cây con bên trái.<br>Pre-Order: " +
              pre_list +
              "..."; //status_preorder_8
            //cs["status"] = 'Visit vertex with value {cur}.<br>And preparing to visit the right child of this vertex.'.replace("{cur}", cur);
            cs["lineNo"] = 3;
            sl.push(cs);

            if (curLeft == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              preorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên trái của nút " +
                cur +
                " là rỗng.<br>Trả về rỗng."; //status_preorder_5
              //cs["status"] = 'The left child of vertex with value {cur} is empty.<br>Return empty.'.replace("{cur}", cur);
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curLeftClass = iBST[curLeft]["vertexClassNumber"];

              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              preorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên trái của nút " +
                cur +
                " là " +
                curLeft +
                " (khác rỗng)."; //status_preorder_6
              //cs["status"] = 'The left child of vertex with value {cur} is {curLeft} (not null).'.replace("{cur}", cur).replace("{curLeft}", curLeft);
              cs["lineNo"] = 3;
              sl.push(cs);
              edgeTraversed[curLeftClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curLeftClass]["animateHighlighted"] = true;
              preorderHighlightVertex(key);
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên trái của nút " +
                curLeft +
                "."; //status_preorder_7
              //cs["status"] = 'So recurse and check left child of vertex with value {curLeft}.'.replace("{curLeft}", curLeft);
              cs["lineNo"] = 4;
              sl.push(cs);
              preorderTraversalRecursion(curLeft);
            }

            if (curRight == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              preorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên phải của nút " +
                cur +
                " là rỗng.<br>Trả về rỗng.<br>"; //status_preorder_9
              //cs["status"] = 'The right child of vertex with value {cur} is empty.<br>Return empty.<br>'.replace("{cur}", cur);
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curRightClass = iBST[curRight]["vertexClassNumber"];

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              preorderHighlightVertex(key);
              cs["status"] =
                "Chuẩn bị gặp nút con bên phải của nút này.<br>Giá trị của nút con bên phải của nút " +
                cur +
                " là " +
                curRight +
                " (khác rỗng)."; //status_preorder_10
              //cs["status"] = 'The right child of vertex with value {cur} is {curRight} (not null).'.replace("{cur}", cur).replace("{curRight}", curRight);
              cs["lineNo"] = 3;
              sl.push(cs);
              edgeTraversed[curRightClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curRightClass]["animateHighlighted"] = true;
              preorderHighlightVertex(key);
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên phải của nút " +
                curRight +
                "."; //status_preorder_7
              //cs["status"] = 'So recurse and check the right child of vertex with value {curRight}.'.replace("{curRight}", curRight);
              cs["lineNo"] = 5;
              sl.push(cs);
              preorderTraversalRecursion(curRight);
            }

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            if (cur != iBST["root"]) cs["el"][key]["state"] = EDGE_HIGHLIGHTED;
            preorderHighlightVertex(key);

            cs["status"] = "Duyệt theo Pre-order của " + cur + " đã hoàn tất."; //status_preorder_12
            //cs["status"] = 'In-order traversal of {cur} is complete.'.replace("{cur}", cur);
            cs["lineNo"] = 0;
            sl.push(cs);
          }

          function preorderHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(10);
          return true;
        };

        this.postorderTraversal = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          cs["status"] = "Cây BST (root)."; //'The current BST.';
          cs["lineNo"] = 0;
          sl.push(cs);

          var post_list = "";

          if (iBST["root"] == null) {
            cs = createState(iBST);
            cs["status"] = "Cây BST rỗng.<br>Trả về giá trị rỗng."; //status_preorder_1
            //cs["status"] = 'The Binary Search Tree is empty.<br>Return empty result.';
            cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            cs["status"] =
              "Gốc " + iBST["root"] + " không phải là giá trị rỗng."; //status_preorder_2
            //cs["status"] = 'The root {root} is not null.'.replace("{root}", iBST["root"]);
            cs["lineNo"] = 1;
            sl.push(cs);

            postorderTraversalRecursion(iBST["root"]);
          }

          cs = createState(iBST, vertexTraversed, edgeTraversed);
          postorderHighlightVertex(key);
          cs["status"] =
            "Quá trình duyệt theo Post-order của toàn bộ BST đã hoàn tất.<br>Kết quả: " +
            post_list.slice(0, -1); //status_preorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function postorderTraversalRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            if (curLeft == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              postorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên trái của nút " +
                cur +
                " là rỗng.<br>Trả về rỗng."; //status_preorder_5
              //cs["status"] = 'The left child of vertex with value {cur} is empty.<br>Return empty.'.replace("{cur}", cur);
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curLeftClass = iBST[curLeft]["vertexClassNumber"];

              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              postorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên trái của nút " +
                cur +
                " là " +
                curLeft +
                " (khác rỗng)."; //status_preorder_6
              //cs["status"] = 'The left child of vertex with value {cur} is {curLeft} (not null).'.replace("{cur}", cur).replace("{curLeft}", curLeft);
              cs["lineNo"] = 3;
              sl.push(cs);
              edgeTraversed[curLeftClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curLeftClass]["animateHighlighted"] = true;
              postorderHighlightVertex(key);
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên trái của nút " +
                curLeft +
                "."; //status_preorder_7
              //cs["status"] = 'So recurse and check left child of vertex with value {curLeft}.'.replace("{curLeft}", curLeft);
              cs["lineNo"] = 4;
              sl.push(cs);
              postorderTraversalRecursion(curLeft);
            }

            if (curRight == null) {
              vertexTraversed[cur] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              postorderHighlightVertex(key);
              cs["status"] =
                "Giá trị của nút con bên phải của nút " +
                cur +
                " là rỗng.<br>Trả về rỗng.<br>"; //status_preorder_9
              //cs["status"] = 'The right child of vertex with value {cur} is empty.<br>Return empty.<br>'.replace("{cur}", cur);
              cs["lineNo"] = [1, 2];
              sl.push(cs);
            } else {
              var curRightClass = iBST[curRight]["vertexClassNumber"];

              cs = createState(iBST, vertexTraversed, edgeTraversed);
              postorderHighlightVertex(key);
              cs["status"] =
                "Chuẩn bị gặp nút con bên phải của nút này.<br>Giá trị của nút con bên phải của nút " +
                cur +
                " là " +
                curRight +
                " (khác rỗng)."; //status_preorder_10
              //cs["status"] = 'The right child of vertex with value {cur} is {curRight} (not null).'.replace("{cur}", cur).replace("{curRight}", curRight);
              cs["lineNo"] = 3;
              sl.push(cs);
              edgeTraversed[curRightClass] = true;
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["el"][curRightClass]["animateHighlighted"] = true;
              postorderHighlightVertex(key);
              cs["status"] =
                "Vì vậy đệ quy và kiểm tra nút con bên phải của nút " +
                curRight +
                "."; //status_preorder_7
              //cs["status"] = 'So recurse and check the right child of vertex with value {curRight}.'.replace("{curRight}", curRight);
              cs["lineNo"] = 5;
              sl.push(cs);
              postorderTraversalRecursion(curRight);
            }

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            vertexHighlighted[key] = true;
            postorderHighlightVertex(key);
            post_list = post_list + cur + ",";
            cs["status"] =
              "Trở lại nút gốc " +
              cur +
              "  và chuẩn bị doàn tất quá trình duyệt.<br>Post-Order: " +
              post_list +
              "..."; //status_inorder_8
            //cs["status"] = 'Visit vertex with value {cur}.<br>And preparing to visit the right child of this vertex.'.replace("{cur}", cur);
            cs["lineNo"] = 4;
            sl.push(cs);

            cs = createState(iBST, vertexTraversed, edgeTraversed);
            if (cur != iBST["root"]) cs["el"][key]["state"] = EDGE_HIGHLIGHTED;
            postorderHighlightVertex(key);

            cs["status"] = "Duyệt theo Post-order của " + cur + " đã hoàn tất."; //status_preorder_12
            //cs["status"] = 'In-order traversal of {cur} is complete.'.replace("{cur}", cur);
            cs["lineNo"] = 0;
            sl.push(cs);
          }

          function postorderHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(11);
          return true;
        };

        this.countAll = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          cs["status"] = "Cây BST (root)."; //'The current BST.';
          //cs["lineNo"] = 0;
          sl.push(cs);

          var count = 0;

          if (iBST["root"] == null) {
            cs = createState(iBST);
            cs["status"] = "Cây BST rỗng.<br>Cây có " + count + " nút."; //status_preorder_1
            //cs["status"] = 'The Binary Search Tree is empty.<br>Return empty result.';
            //cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            cs["status"] =
              "Gốc " +
              iBST["root"] +
              " không phải là giá trị rỗng. Bắt đầu đếm"; //status_preorder_2
            //cs["status"] = 'The root {root} is not null.'.replace("{root}", iBST["root"]);
            //cs["lineNo"] = 1;
            sl.push(cs);

            countAllRecursion(iBST["root"]);
          }
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          countHighlightVertex(key);
          cs["status"] = "Đếm hoàn tất.<br>Kết quả: " + count + " nút."; //status_preorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          //cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function countAllRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            if (curLeft == null) {
              vertexTraversed[cur] = true;
              countHighlightVertex(key);
            } else {
              var curLeftClass = iBST[curLeft]["vertexClassNumber"];
              vertexTraversed[cur] = true;
              countHighlightVertex(key);
              edgeTraversed[curLeftClass] = true;
              countHighlightVertex(key);
              countAllRecursion(curLeft);
            }

            if (curRight == null) {
              vertexTraversed[cur] = true;
              countHighlightVertex(key);
            } else {
              var curRightClass = iBST[curRight]["vertexClassNumber"];
              vertexTraversed[cur] = true;
              countHighlightVertex(key);
              edgeTraversed[curRightClass] = true;
              countHighlightVertex(key);
              countAllRecursion(curRight);
            }

            vertexHighlighted[key] = true;
            countHighlightVertex(key);
            count++;
          }

          function countHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            // for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            // cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(12);
          return true;
        };

        this.countLeaf = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          cs["status"] = "Cây BST (root)."; //'The current BST.';
          //cs["lineNo"] = 0;
          sl.push(cs);

          var count = 0;

          if (iBST["root"] == null) {
            cs = createState(iBST);
            cs["status"] = "Cây BST rỗng.<br>Cây có " + count + " nút lá."; //status_preorder_1
            //cs["status"] = 'The Binary Search Tree is empty.<br>Return empty result.';
            //cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            cs["status"] =
              "Gốc " +
              iBST["root"] +
              " không phải là giá trị rỗng. Bắt đầu đếm"; //status_preorder_2
            //cs["status"] = 'The root {root} is not null.'.replace("{root}", iBST["root"]);
            //cs["lineNo"] = 1;
            sl.push(cs);

            countLeafRecursion(iBST["root"]);
          }
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          countHighlightVertex(key);
          cs["status"] = "Đếm hoàn tất.<br>Kết quả: " + count + " nút."; //status_preorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          //cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function countLeafRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            if (curLeft == null && curRight == null) {
              vertexTraversed[cur] = true;
              countHighlightVertex(key);
              count++;
            }
            if (curLeft != null) {
              countLeafRecursion(curLeft);
            }
            if (curRight != null) {
              countLeafRecursion(curRight);
            }
          }

          function countHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            // for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            // cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(13);
          return true;
        };

        this.countMedium = function (callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key;
          var vertexHighlighted = {};

          cs = createState(iBST);
          cs["status"] = "Cây BST (root)."; //'The current BST.';
          //cs["lineNo"] = 0;
          sl.push(cs);

          var count = 0;

          if (iBST["root"] == null) {
            cs = createState(iBST);
            cs["status"] =
              "Cây BST rỗng.<br>Cây có " + count + " nút trung gian."; //status_preorder_1
            //cs["status"] = 'The Binary Search Tree is empty.<br>Return empty result.';
            //cs["lineNo"] = [1, 2];
            sl.push(cs);
            return true;
          } else {
            key = iBST[iBST["root"]]["vertexClassNumber"];

            cs = createState(iBST);
            cs["vl"][key]["state"] = VERTEX_TRAVERSED;
            cs["vl"][key]["extratext"] = "root";
            cs["status"] =
              "Gốc " +
              iBST["root"] +
              " không phải là giá trị rỗng. Bắt đầu đếm"; //status_preorder_2
            //cs["status"] = 'The root {root} is not null.'.replace("{root}", iBST["root"]);
            //cs["lineNo"] = 1;
            sl.push(cs);

            countMediumRecursion(iBST["root"]);
          }
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          countHighlightVertex(key);
          cs["status"] = "Đếm hoàn tất.<br>Kết quả: " + count + " nút."; //status_preorder_4
          //cs["status"] = 'In-order traversal of the whole BST is complete.';
          cs["vl"][key]["extratext"] = "root";
          //cs["lineNo"] = 0;
          sl.push(cs);

          gw.startAnimation(sl, callback);

          function countMediumRecursion(cur) {
            var curLeft = iBST[cur]["leftChild"],
              curRight = iBST[cur]["rightChild"];
            var key = iBST[cur]["vertexClassNumber"];

            if (cur == iBST["root"]) {
              if (curLeft != null) {
                countMediumRecursion(curLeft);
              }
              if (curRight != null) {
                countMediumRecursion(curRight);
              }
            } else {
              if (curLeft != null || curRight != null) {
                vertexTraversed[cur] = true;
                countHighlightVertex(key);
                count++;
                if (curLeft != null) countMediumRecursion(curLeft);
                if (curRight != null) countMediumRecursion(curRight);
              }
            }
          }

          function countHighlightVertex(curkey) {
            for (var key in vertexHighlighted)
              cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
            // for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
            // cs["vl"][curkey]["extratext"] = "^";
          }
          populatePseudocode(14);
          return true;
        };

        this.insertArr = function (vertexTextArr, callback) {
          var sl = [],
            vertexTraversed = {},
            edgeTraversed = {},
            cur = iBST["root"],
            cs,
            key,
            currentVertexClass,
            i;

          cs = createState(iBST);
          //cs["status"] = "The current BST.";  //status_insert_0
          cs["status"] = "Cây BST (root).";
          cs["lineNo"] = 0;
          sl.push(cs);

          // Check whether input is array
          if (
            Object.prototype.toString.call(vertexTextArr) != "[object Array]"
          ) {
            $("#insert-err").html(
              "Hãy nhập vào một số hoặc một dãy số cách nhau bằng dấu phẩy!"
            );
            return false;
          }

          // Loop through all array values and...
          var tempiBST = deepCopy(iBST); // Use this to simulate internal insertion

          for (i = 0; i < vertexTextArr.length; ++i) {
            var vt = parseInt(vertexTextArr[i]);

            // 1. Check whether value is number
            if (isNaN(vt)) {
              $("#insert-err").html(
                "Hãy nhập vào một số hoặc một dãy số cách nhau bằng dấu phẩy!"
              );
              return false;
            }

            // 2. No duplicates allowed. Also works if more than one similar value are inserted
            if (tempiBST[vt] != null) {
              $("#insert-err").html(
                "Không cho phép trùng lặp giá trị của nút!"
              );
              if (typeof callback == "function") callback();
              return false;
            }

            // 3. Check range
            if (parseInt(vt) < valueRange[0] || parseInt(vt) > valueRange[1]) {
              $("#insert-err").html(
                "Xin lỗi, chỉ những giá trị trong khoảng từ {range1} dến {range2} có thể được thêm vào."
                  .replace("{range1}", valueRange[0])
                  .replace("{range2}", valueRange[1])
              );
              return false;
            }

            // 4. Insert the node into temporary internal structure and check for height
            var parentVertex = tempiBST["root"];
            var heightCounter = 0;

            if (parentVertex == null) {
              tempiBST["root"] = parseInt(vt);
              tempiBST[vt] = {
                parent: null,
                leftChild: null,
                rightChild: null,
              };
            } else {
              while (true) {
                heightCounter++;
                if (parentVertex < vt) {
                  if (tempiBST[parentVertex]["rightChild"] == null) break;
                  parentVertex = tempiBST[parentVertex]["rightChild"];
                } else {
                  if (tempiBST[parentVertex]["leftChild"] == null) break;
                  parentVertex = tempiBST[parentVertex]["leftChild"];
                }
              }

              if (parentVertex < vt) tempiBST[parentVertex]["rightChild"] = vt;
              else tempiBST[parentVertex]["leftChild"] = vt;

              tempiBST[vt] = {
                parent: parentVertex,
                leftChild: null,
                rightChild: null,
              };
            }

            heightCounter++; // New vertex added will add new height

            if (heightCounter > maxHeightAllowed + 1) {
              $("#insert-err").html(
                "Xin lỗi, hiện tại chỉ có thể hỗ trợ cây có chiều cao tối đa là {maxHeight}".replace(
                  "{maxHeight}",
                  maxHeightAllowed
                )
              );
              if (typeof callback == "function") callback();
              return false;
            }
          }

          function checkNewHeight() {
            var parentVertex = tempiBST["root"];
            var heightCounter = 0;

            while (parentVertex != null) {
              if (parentVertex < parseInt(val))
                parentVertex = tempiBST[parentVertex]["rightChild"];
              else parentVertex = tempiBST[parentVertex]["leftChild"];
              ++heightCounter;
            }

            ++heightCounter; // New vertex added will add new height

            if (heightCounter > maxHeightAllowed + 1) return false;
            return true;
          }

          for (i = 0; i < vertexTextArr.length; ++i) {
            var val = parseInt(vertexTextArr[i]);

            // Re-initialization
            vertexTraversed = {};
            edgeTraversed = {};
            cur = iBST["root"];
            cs = createState(iBST);

            // Find parent
            while (cur != val && cur != null) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              currentVertexClass = iBST[cur]["vertexClassNumber"];

              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              vertexTraversed[cur] = true;

              //cs["status"] = "Comparing " + val + " with " + cur; //status_insert_1
              cs["status"] = "So sánh {val} với {cur}"
                .replace("{val}", val)
                .replace("{cur}", cur);
              cs["lineNo"] = 3;

              sl.push(cs);

              var nextVertex;
              if (parseInt(val) > parseInt(cur))
                nextVertex = iBST[cur]["rightChild"];
              else nextVertex = iBST[cur]["leftChild"];

              if (nextVertex == null) break;
              else cur = nextVertex;

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              var edgeHighlighted = iBST[cur]["vertexClassNumber"];
              edgeTraversed[edgeHighlighted] = true;

              cs["el"][edgeHighlighted]["animateHighlighted"] = true;
              cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

              if (parseInt(val) > parseInt(iBST[cur]["parent"])) {
                //cs["status"] = val + " is larger than " + iBST[cur]["parent"] + ", so go right."; //status_insert_2
                cs["status"] = "{val} lớn hơn {parent}, đi qua phải."
                  .replace("{val}", val)
                  .replace("{parent}", iBST[cur]["parent"]);
                cs["lineNo"] = 5;
              } else {
                //cs["status"] = val + " is smaller than " + iBST[cur]["parent"] + ", so go left."; //status_insert_3
                cs["status"] = "{val} nhỏ hơn {parent}, đi qua trái."
                  .replace("{val}", val)
                  .replace("{parent}", iBST[cur]["parent"]);
                cs["lineNo"] = 4;
              }

              sl.push(cs);
            }

            // Begin insertion
            // First, update internal representation
            iBST[parseInt(val)] = {
              leftChild: null,
              rightChild: null,
              vertexClassNumber: amountVertex,
            };

            if (cur != null) {
              iBST[parseInt(val)]["parent"] = cur;
              if (cur < parseInt(val)) iBST[cur]["rightChild"] = parseInt(val);
              else iBST[cur]["leftChild"] = parseInt(val);
            } else {
              iBST[parseInt(val)]["parent"] = null;
              iBST["root"] = parseInt(val);
            }

            ++amountVertex;
            recalculatePosition();

            // Then, draw edge
            var newNodeVertexClass = iBST[parseInt(val)]["vertexClassNumber"];

            if (cur != null) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              cs["vl"][newNodeVertexClass]["state"] = OBJ_HIDDEN;

              cs["el"][newNodeVertexClass]["state"] = EDGE_TRAVERSED;
              cs["el"][newNodeVertexClass]["animateHighlighted"] = true;

              //cs["status"] = "Location found!<br>Inserting " + val + "."; //status_insert_4
              cs["status"] = "Đã tìm thấy vị trí!<br>Đang thêm {val}.".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 1;

              sl.push(cs);

              edgeTraversed[newNodeVertexClass] = true;
            }

            // Lastly, draw vertex
            cs = createState(iBST, vertexTraversed, edgeTraversed);
            cs["vl"][newNodeVertexClass]["state"] = VERTEX_HIGHLIGHTED; // EDGE_HIGHLIGHTED;
            cs["vl"][newNodeVertexClass]["extratext"] = "v";

            //cs["status"] = val + " has been inserted!"  //status_insert_5
            cs["status"] = "{val} đã được thêm!".replace("{val}", val);
            cs["lineNo"] = 2;
            sl.push(cs);
          }

          gw.startAnimation(sl, callback);
          populatePseudocode(0);
          return true;
        };

        this.removeArr = function (vertexTextArr, callback) {
          var sl = [];
          var vertexTraversed = {};
          var edgeTraversed = {};
          var cur = iBST["root"];
          var cs = createState(iBST);
          var currentVertexClass;
          var key;
          var i;

          //cs["status"] = "The current BST"; //status_remove_0
          cs["status"] = "Cây BST (root)";
          cs["lineNo"] = 0;
          sl.push(cs);

          if (
            Object.prototype.toString.call(vertexTextArr) != "[object Array]"
          ) {
            $("#remove-err").html(
              "Hãy nhập vào một số hoặc một dãy số cách nhau bằng dấu phẩy!"
            );
            return false;
          }

          // Loop through all array values and...
          for (i = 0; i < vertexTextArr.length; ++i) {
            var vt = parseInt(vertexTextArr[i]);

            // Check whether value is number
            if (isNaN(vt)) {
              $("#remove-err").html(
                "Hãy nhập vào một số hoặc một dãy số cách nhau bằng dấu phẩy!"
              );
              return false;
            }
            // Other checks not required
          }

          for (i = 0; i < vertexTextArr.length; ++i) {
            var val = parseInt(vertexTextArr[i]);
            var vertexCheckBf;

            // Re-initialization
            vertexTraversed = {};
            edgeTraversed = {};
            cur = iBST["root"];
            cs = createState(iBST);

            // Find vertex
            while (cur != val && cur != null) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              currentVertexClass = iBST[cur]["vertexClassNumber"];

              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              vertexTraversed[cur] = true;

              //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
              cs["status"] = "Đang tìm nút {val} để xóa".replace("{val}", val);
              cs["lineNo"] = 1;
              sl.push(cs);

              if (parseInt(val) > parseInt(cur)) cur = iBST[cur]["rightChild"];
              else cur = iBST[cur]["leftChild"];

              if (cur == null) break;

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              var edgeHighlighted = iBST[cur]["vertexClassNumber"];
              edgeTraversed[edgeHighlighted] = true;

              cs["el"][edgeHighlighted]["animateHighlighted"] = true;
              cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

              //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
              cs["status"] = "Đang tìm nút {val} để xóa".replace("{val}", val);
              cs["lineNo"] = 1;
              sl.push(cs);
            }

            if (cur != null) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              currentVertexClass = iBST[cur]["vertexClassNumber"];

              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
              cs["status"] = "Đang tìm nút {val} để xóa".replace("{val}", val);
              cs["lineNo"] = 1;
              sl.push(cs);
            }
            // Vertex is not inside the tree
            else {
              cs = createState(iBST);
              //cs["status"] = "Node " + val + " is not in the BST";  //status_remove_2
              cs["status"] = "Không có nút {val} trong BST".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 0; //Node {val} is not in the BST
              sl.push(cs);
              continue;
            }

            // Vertex found; begin deletion
            // Case 1: no child
            if (
              iBST[cur]["leftChild"] == null &&
              iBST[cur]["rightChild"] == null
            ) {
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              //cs["status"] = "Node " + val + " has no children. It is a leaf."; //status_remove_3
              cs["status"] = "Nút {val} không có nút con. Là nút lá.".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 2;
              sl.push(cs);

              var parentVertex = iBST[cur]["parent"];

              if (parentVertex != null) {
                if (parseInt(parentVertex) < parseInt(cur))
                  iBST[parentVertex]["rightChild"] = null;
                else iBST[parentVertex]["leftChild"] = null;
              } else iBST["root"] = null;

              currentVertexClass = iBST[cur]["vertexClassNumber"];
              delete iBST[cur];
              delete vertexTraversed[cur];
              delete edgeTraversed[currentVertexClass];

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              //cs["status"] = "Remove leaf " + val;  //status_remove_4
              cs["status"] = "Xóa nút lá {val}".replace("{val}", val);
              cs["lineNo"] = 3;
              sl.push(cs);

              vertexCheckBf = parentVertex;
            }
            // Case 2: One child
            else if (iBST[cur]["leftChild"] == null) {
              // Only right child
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              //cs["status"] = "Node " + val + " has a right child only"; //status_remove_5
              cs["status"] = "Nút {val} chỉ có nút con bên phải".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 4;
              sl.push(cs);

              var parentVertex = iBST[cur]["parent"];
              var rightChildVertex = iBST[cur]["rightChild"];

              if (parentVertex != null) {
                if (parseInt(parentVertex) < parseInt(cur))
                  iBST[parentVertex]["rightChild"] = rightChildVertex;
                else iBST[parentVertex]["leftChild"] = rightChildVertex;
              } else iBST["root"] = rightChildVertex;

              iBST[rightChildVertex]["parent"] = parentVertex;

              currentVertexClass = iBST[cur]["vertexClassNumber"];
              rightChildVertexClass =
                iBST[rightChildVertex]["vertexClassNumber"];
              delete iBST[cur];
              delete vertexTraversed[cur];
              delete edgeTraversed[currentVertexClass];

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              if (parentVertex != null)
                cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              //cs["status"] = "Delete node " + val + " and connect its parent to its right child"; //status_remove_6
              cs["status"] =
                "Xóa nút {val} và nối nút cha với nút con bên phải của nó".replace(
                  "{val}",
                  val
                );
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              if (parentVertex != null)
                cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              //cs["status"] = "Re-layout the tree";  //status_remove_7
              cs["status"] = "Bố trí lại cây";
              cs["lineNo"] = 5;
              sl.push(cs);

              vertexCheckBf = rightChildVertex;
            } else if (iBST[cur]["rightChild"] == null) {
              // Only left child
              cs = createState(iBST, vertexTraversed, edgeTraversed);
              //cs["status"] = "Node " + val + " has a left child only";  //status_remove_8
              cs["status"] = "Nút {val} chỉ có nút con bên trái".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 4;
              sl.push(cs);

              var parentVertex = iBST[cur]["parent"];
              var leftChildVertex = iBST[cur]["leftChild"];

              if (parentVertex != null) {
                if (parseInt(parentVertex) < parseInt(cur))
                  iBST[parentVertex]["rightChild"] = leftChildVertex;
                else iBST[parentVertex]["leftChild"] = leftChildVertex;
              } else iBST["root"] = leftChildVertex;

              iBST[leftChildVertex]["parent"] = parentVertex;

              currentVertexClass = iBST[cur]["vertexClassNumber"];
              leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];
              delete iBST[cur];
              delete vertexTraversed[cur];
              delete edgeTraversed[currentVertexClass];

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              if (parentVertex != null)
                cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              //cs["status"] = "Delete node " + val + " and connect its parent to its left child";  //status_remove_9
              cs["status"] =
                "Xóa nút {val} và nối nút cha với nút con bên trái của nó".replace(
                  "{val}",
                  val
                );
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              if (parentVertex != null)
                cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              //cs["status"] = "Re-layout the tree";  //status_remove_7
              cs["status"] = "Bố trí lại cây";
              cs["lineNo"] = 5;
              sl.push(cs);

              vertexCheckBf = leftChildVertex;
            } else {
              // Case 3: two children
              var parentVertex = iBST[cur]["parent"];
              var leftChildVertex = iBST[cur]["leftChild"];
              var rightChildVertex = iBST[cur]["rightChild"];
              var successorVertex = iBST[cur]["rightChild"];
              var successorVertexClass =
                iBST[successorVertex]["vertexClassNumber"];

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
              cs["el"][successorVertexClass]["animateHighlighted"] = true;

              //cs["status"] = "Finding successor of " + val; //status_remove_10
              cs["status"] = "Đang tìm nút kế nhiệm của {val}".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 6;
              sl.push(cs);

              edgeTraversed[successorVertexClass] = true;
              vertexTraversed[successorVertex] = true;

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

              //cs["status"] = "Finding successor of " + val; //status_remove_10
              cs["status"] = "Đang tìm nút kế nhiệm của {val}".replace(
                "{val}",
                val
              );
              cs["lineNo"] = 6;
              sl.push(cs);

              while (iBST[successorVertex]["leftChild"] != null) {
                successorVertex = iBST[successorVertex]["leftChild"];
                successorVertexClass =
                  iBST[successorVertex]["vertexClassNumber"];

                cs = createState(iBST, vertexTraversed, edgeTraversed);

                cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

                cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
                cs["el"][successorVertexClass]["animateHighlighted"] = true;

                //cs["status"] = "Finding successor of " + val; //status_remove_10
                cs["status"] = "Đang tìm nút kế nhiệm của {val}".replace(
                  "{val}",
                  val
                );
                cs["lineNo"] = 6;
                sl.push(cs);

                edgeTraversed[successorVertexClass] = true;
                vertexTraversed[successorVertex] = true;

                cs = createState(iBST, vertexTraversed, edgeTraversed);

                cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

                //cs["status"] = "Finding successor of " + val; //status_remove_10
                cs["status"] = "Đang tìm nút kế nhiệm của {val}".replace(
                  "{val}",
                  val
                );
                cs["lineNo"] = 6;
                sl.push(cs);
              }

              var successorParentVertex = iBST[successorVertex]["parent"];
              var successorRightChildVertex =
                iBST[successorVertex]["rightChild"];

              // Update internal representation
              if (parentVertex != null) {
                if (parseInt(parentVertex) < parseInt(cur))
                  iBST[parentVertex]["rightChild"] = successorVertex;
                else iBST[parentVertex]["leftChild"] = successorVertex;
              } else iBST["root"] = successorVertex;

              iBST[successorVertex]["parent"] = parentVertex;
              iBST[successorVertex]["leftChild"] = leftChildVertex;

              iBST[leftChildVertex]["parent"] = successorVertex;

              if (successorVertex != rightChildVertex) {
                iBST[successorVertex]["rightChild"] = rightChildVertex;
                iBST[rightChildVertex]["parent"] = successorVertex;

                if (successorRightChildVertex != null) {
                  if (
                    parseInt(successorParentVertex) < parseInt(successorVertex)
                  )
                    iBST[successorParentVertex]["rightChild"] =
                      successorRightChildVertex;
                  else
                    iBST[successorParentVertex]["leftChild"] =
                      successorRightChildVertex;
                  iBST[successorRightChildVertex]["parent"] =
                    successorParentVertex;
                } else {
                  if (
                    parseInt(successorParentVertex) < parseInt(successorVertex)
                  )
                    iBST[successorParentVertex]["rightChild"] = null;
                  else iBST[successorParentVertex]["leftChild"] = null;
                }
              }

              delete iBST[cur];
              delete vertexTraversed[cur];
              delete edgeTraversed[currentVertexClass];

              if (parentVertex == null)
                delete edgeTraversed[successorVertexClass];

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              var leftChildVertexClass =
                iBST[leftChildVertex]["vertexClassNumber"];

              cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              if (parentVertex != null) {
                var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
                cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
              }

              if (successorVertex != rightChildVertex) {
                var rightChildVertexClass =
                  iBST[rightChildVertex]["vertexClassNumber"];
                cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

                if (successorRightChildVertex != null) {
                  var successorRightChildVertexClass =
                    iBST[successorRightChildVertex]["vertexClassNumber"];
                  cs["el"][successorRightChildVertexClass]["state"] =
                    EDGE_HIGHLIGHTED;
                }
              }

              //cs["status"] = "Replace node " + val + " with its successor"; //status_remove_11
              cs["status"] =
                "Thay thế nút {val} với nút kế nhiệm của nó".replace(
                  "{val}",
                  val
                );
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST, vertexTraversed, edgeTraversed);

              leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];

              cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

              if (parentVertex != null) {
                var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
                cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
              }

              if (successorVertex != rightChildVertex) {
                var rightChildVertexClass =
                  iBST[rightChildVertex]["vertexClassNumber"];
                cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

                if (successorRightChildVertex != null) {
                  var successorRightChildVertexClass =
                    iBST[successorRightChildVertex]["vertexClassNumber"];
                  cs["el"][successorRightChildVertexClass]["state"] =
                    EDGE_HIGHLIGHTED;
                }
              }

              //cs["status"] = "Re-layout the tree";  //status_remove_7
              cs["status"] = "Bố trí lại cây";
              cs["lineNo"] = 6;
              sl.push(cs);

              vertexCheckBf = successorVertex;
              if (successorVertex != rightChildVertex)
                vertexCheckBf = successorParentVertex;
            }

            cs = createState(iBST);
            //cs["status"] = "Removal of " + val + " completed";  //status_remove_12
            cs["status"] = "Xóa nút {val} hoàn tất".replace("{val}", val);
            cs["lineNo"] = 0;
            sl.push(cs);
          }

          gw.startAnimation(sl, callback);
          populatePseudocode(5);
          return true;
        };

        function init(initArr) {
          var i;

          clearScreen();

          for (i = 0; i < initArr.length; ++i) {
            var parentVertex = iBST["root"];
            var newVertex = parseInt(initArr[i]);

            if (parentVertex == null) {
              iBST["root"] = parseInt(newVertex);
              iBST[newVertex] = {
                parent: null,
                leftChild: null,
                rightChild: null,
                vertexClassNumber: amountVertex,
              };
            } else {
              while (true) {
                if (parentVertex < newVertex) {
                  if (iBST[parentVertex]["rightChild"] == null) break;
                  parentVertex = iBST[parentVertex]["rightChild"];
                } else {
                  if (iBST[parentVertex]["leftChild"] == null) break;
                  parentVertex = iBST[parentVertex]["leftChild"];
                }
              }

              if (parentVertex < newVertex)
                iBST[parentVertex]["rightChild"] = newVertex;
              else iBST[parentVertex]["leftChild"] = newVertex;

              iBST[newVertex] = {
                parent: parentVertex,
                leftChild: null,
                rightChild: null,
                vertexClassNumber: amountVertex,
              };
            }

            ++amountVertex;
          }

          recalculatePosition();

          for (key in iBST) {
            if (key == "root") continue;
            gw.addVertex(
              iBST[key]["cx"],
              iBST[key]["cy"],
              key,
              iBST[key]["vertexClassNumber"],
              true
            );
          }

          for (key in iBST) {
            if (key == "root") continue;
            if (key == iBST["root"]) continue;
            var parentVertex = iBST[key]["parent"];
            gw.addEdge(
              iBST[parentVertex]["vertexClassNumber"],
              iBST[key]["vertexClassNumber"],
              iBST[key]["vertexClassNumber"],
              EDGE_TYPE_UDE,
              1,
              true
            );
          }
        }

        function clearScreen() {
          var key;

          for (key in iBST) {
            if (key == "root") continue;
            gw.removeEdge(iBST[key]["vertexClassNumber"]);
          }

          for (key in iBST) {
            if (key == "root") continue;
            gw.removeVertex(iBST[key]["vertexClassNumber"]);
          }

          iBST = {};
          iBST["root"] = null;
          amountVertex = 0;
        }

        // Pseudocode for rotateLeft:
        /*
         * BSTVertex rotateLeft(BSTVertex T) // pre-req: T.right != null
         * BSTVertex w = T.right
         * w.parent = T.parent
         * T.parent = w
         * T.right = w.left
         * if (w.left != null) w.left.parent = T
         * w.left = T
         * // Update the height of T and then w
         * return w
         */

        function rotateLeft(val) {
          // Refer to pseudocode

          var t = parseInt(val);
          var w = iBST[t]["rightChild"];

          iBST[w]["parent"] = iBST[t]["parent"];
          if (iBST[t]["parent"] != null) {
            if (iBST[t]["parent"] < t) {
              var tParent = iBST[t]["parent"];
              iBST[tParent]["rightChild"] = w;
            } else {
              var tParent = iBST[t]["parent"];
              iBST[tParent]["leftChild"] = w;
            }
          }

          iBST[t]["parent"] = w;
          iBST[t]["rightChild"] = iBST[w]["leftChild"];
          if (iBST[w]["leftChild"] != null)
            iBST[iBST[w]["leftChild"]]["parent"] = t;
          iBST[w]["leftChild"] = t;

          if (t == iBST["root"]) iBST["root"] = w;

          recalculateBalanceFactor();
        }

        function rotateRight(val) {
          // Refer to pseudocode

          var t = parseInt(val);
          var w = iBST[t]["leftChild"];

          iBST[w]["parent"] = iBST[t]["parent"];
          if (iBST[t]["parent"] != null) {
            if (iBST[t]["parent"] < t) {
              var tParent = iBST[t]["parent"];
              iBST[tParent]["rightChild"] = w;
            } else {
              var tParent = iBST[t]["parent"];
              iBST[tParent]["leftChild"] = w;
            }
          }

          iBST[t]["parent"] = w;
          iBST[t]["leftChild"] = iBST[w]["rightChild"];
          if (iBST[w]["rightChild"] != null)
            iBST[iBST[w]["rightChild"]]["parent"] = t;
          iBST[w]["rightChild"] = t;

          if (t == iBST["root"]) iBST["root"] = w;

          recalculateBalanceFactor();
        }

        /*
         * iBSTObject: a JS object with the same structure of iBST. This means the BST doen't have to be the BST stored in this class
         * vertexTraversed: JS object with the vertexes of the BST which are to be marked as traversed as the key
         * edgeTraversed: JS object with the edges of the BST which are to be marked as traversed as the key
         */

        function createState(iBSTObject, vertexTraversed, edgeTraversed) {
          if (
            vertexTraversed == null ||
            vertexTraversed == undefined ||
            !(vertexTraversed instanceof Object)
          )
            vertexTraversed = {};
          if (
            edgeTraversed == null ||
            edgeTraversed == undefined ||
            !(edgeTraversed instanceof Object)
          )
            edgeTraversed = {};

          var state = {
            vl: {},
            el: {},
          };

          var key;
          var vertexClass;

          // something may be inconsistent during remove (AVL?), generates mini D3 error..., hunt for that bug
          for (key in iBSTObject) {
            if (key == "root") continue;

            vertexClass = iBSTObject[key]["vertexClassNumber"];

            state["vl"][vertexClass] = {};
            state["vl"][vertexClass]["cx"] = iBSTObject[key]["cx"];
            state["vl"][vertexClass]["cy"] = iBSTObject[key]["cy"];
            state["vl"][vertexClass]["text"] = key;
            state["vl"][vertexClass]["state"] = VERTEX_DEFAULT;

            if (iBSTObject[key]["parent"] == null) continue;

            parentChildEdgeId = iBSTObject[key]["vertexClassNumber"];

            state["el"][parentChildEdgeId] = {};
            state["el"][parentChildEdgeId]["vertexA"] =
              iBSTObject[iBSTObject[key]["parent"]]["vertexClassNumber"];
            state["el"][parentChildEdgeId]["vertexB"] =
              iBSTObject[key]["vertexClassNumber"];
            state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_UDE;
            state["el"][parentChildEdgeId]["weight"] = 1;
            state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
            state["el"][parentChildEdgeId]["animateHighlighted"] = false;
          }

          for (key in vertexTraversed) {
            vertexClass = iBSTObject[key]["vertexClassNumber"];
            state["vl"][vertexClass]["state"] = VERTEX_TRAVERSED;
          }

          for (key in edgeTraversed) {
            state["el"][key]["state"] = EDGE_TRAVERSED;
          }

          return state;
        }

        function recalculatePosition() {
          calcHeight(iBST["root"], 0);
          updatePosition(iBST["root"]);

          function calcHeight(cur, currentHeight) {
            if (cur == null) return;
            iBST[cur]["height"] = currentHeight;
            calcHeight(iBST[cur]["leftChild"], currentHeight + 1);
            calcHeight(iBST[cur]["rightChild"], currentHeight + 1);
          }

          function updatePosition(cur) {
            if (cur == null) return;

            if (cur == iBST["root"]) iBST[cur]["cx"] = MAIN_SVG_WIDTH / 2;
            else {
              var i;
              var xAxisOffset = MAIN_SVG_WIDTH / 2 - 16;
              var parentVertex = iBST[cur]["parent"];
              for (i = 0; i < iBST[cur]["height"]; ++i) xAxisOffset /= 2;

              if (parseInt(cur) > parseInt(parentVertex))
                iBST[cur]["cx"] = iBST[parentVertex]["cx"] + xAxisOffset;
              else iBST[cur]["cx"] = iBST[parentVertex]["cx"] - xAxisOffset;
            }

            iBST[cur]["cy"] = 25 + 40 * iBST[cur]["height"]; // 26 Feb, 50 + 50* to 25 + 40*, for mobile
            updatePosition(iBST[cur]["leftChild"]);
            updatePosition(iBST[cur]["rightChild"]);
          }
        }

        function recalculateBalanceFactor() {
          balanceFactorRecursion(iBST["root"]);

          function balanceFactorRecursion(val) {
            if (val == null) return -1;

            var balanceFactorHeightLeft = balanceFactorRecursion(
              iBST[val]["leftChild"]
            );
            var balanceFactorHeightRight = balanceFactorRecursion(
              iBST[val]["rightChild"]
            );

            iBST[val]["balanceFactorHeight"] =
              Math.max(balanceFactorHeightLeft, balanceFactorHeightRight) + 1;
            iBST[val]["balanceFactor"] =
              balanceFactorHeightLeft - balanceFactorHeightRight;

            return iBST[val]["balanceFactorHeight"];
          }
        }

        // 1: Max
        // 2: Min
        function populatePseudocode(act) {
          switch (act) {
            case 1: // findMinMax
            case 2:
              //$('#code1').html('if this is null return empty'); // code_minmax_1
              $("#code1").html("if this == null return empty");
              if (act == 1) {
                //$('#code2').html('if right != null'); // code_max_2
                //$('#code3').html('&nbsp&nbspgo right'); // code_max_3
                $("#code2").html("if right != null");
                $("#code3").html("&nbsp&nbspgo right");
              } else {
                //$('#code2').html('if left != null');  // code_min_2
                //$('#code3').html('&nbsp;&nbsp;go left');  // code_min_3
                $("#code2").html("if left != null");
                $("#code3").html("&nbsp;&nbsp;go left");
              }
              //$('#code4').html('else return this key'); // code_minmax_4
              $("#code4").html("else return this");
              $("#code5").html("");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 4: // search
              //$('#code1').html('if this == null');  //code_search_1
              $("#code1").html("if this == null");
              //$('#code2').html('&nbsp;&nbsp;return null');  //code_search_2
              $("#code2").html("&nbsp;&nbsp;return null");
              //$('#code3').html('else if this key == search value'); //code_search_3
              $("#code3").html("else if this == search value");
              //$('#code4').html('&nbsp;&nbsp;return this');  //code_search_4
              $("#code4").html("&nbsp;&nbsp;return this");
              //$('#code5').html('else if this key < search value');  //code_search_5
              $("#code5").html("else if this < search value");
              //$('#code6').html('&nbsp;&nbsp;search right'); //code_search_6
              $("#code6").html("&nbsp;&nbsp;search right");
              //$('#code7').html('else search left'); //code_search_7
              $("#code7").html("else search left");
              break;
            case 0: // Insert
              //$('#code1').html('if insertion point is found');  //code_insert_1
              $("#code1").html("if insertion point is found");
              //$('#code2').html('&nbsp;&nbsp;create new vertex');  //code_insert_2
              $("#code2").html("&nbsp;&nbsp;create new node");
              //$('#code3').html('if value to be inserted < this key'); //code_insert_3
              $("#code3").html("if insert value < this");
              //$('#code4').html('&nbsp;&nbsp;go left');  //code_insert_4
              $("#code4").html("&nbsp;&nbsp;go left");
              //$('#code5').html('else go right');  //code_insert_5
              $("#code5").html("else go right");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 5: // remove
              //$('#code1').html('search for v'); //code_remove_1
              $("#code1").html("search for v");
              //$('#code2').html('if v is a leaf'); //code_remove_2
              $("#code2").html("if v is leaf");
              //$('#code3').html('&nbsp;&nbsp;delete leaf v');  //code_remove_3
              $("#code3").html("&nbsp;&nbsp;delete leaf v");
              //$('#code4').html('else if v has 1 child');  //code_remove_4
              $("#code4").html("else if v has 1 child");
              //$('#code5').html('&nbsp;&nbsp;bypass v'); //code_remove_5
              $("#code5").html("&nbsp;&nbsp;bypass v");
              //$('#code6').html('else replace v with successor');  //code_remove_6
              $("#code6").html("else replace v with successor");
              $("#code7").html("");
              break;
            case 8: // successor
            case 9: // predecessor
              if (act == 8) {
                //$('#code1').html('if this.right != null return findMin(this.right)'); //code_successor_1
                //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.right)'); //code_successor_4
                $("#code1").html(
                  "if this.right != null return findMin(this.right)"
                );
                $("#code4").html(
                  "&nbsp;&nbsp;while(p != null && T == p.right)"
                );
              } else {
                //$('#code1').html('if this.left != null return findMax(this.left)'); //code_predecessor_1
                //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.left)');  //code_predecessor_4
                $("#code1").html(
                  "if this.left != null return findMax(this.left)"
                );
                $("#code4").html("&nbsp;&nbsp;while(p != null && T == p.left)");
              }
              //$('#code2').html('else'); //code_predsucc_2
              $("#code2").html("else");
              //$('#code3').html('&nbsp;&nbsp;p = this.parent, T = this');  //code_predsucc_3
              $("#code3").html("&nbsp;&nbsp;p = this.parent, T = this");
              //$('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent');  //code_predsucc_5
              $("#code5").html("&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent");
              //$('#code6').html('&nbsp;&nbsp;if p is null return -1'); //code_predsucc_6
              $("#code6").html("&nbsp;&nbsp;if p == null return -1");
              //$('#code7').html('&nbsp;&nbsp;else return p');  //code_predsucc_7
              $("#code7").html("&nbsp;&nbsp;else return p");
              break;
            case 3: // inorder traversal
              $("#code1").html("if this == null"); //code_inorder_1
              $("#code2").html("&nbsp;&nbsp;return"); //code_inorder_2
              $("#code3").html("inOrder(left)"); //code_inorder_3
              $("#code4").html("visit this"); ////code_inorder_4
              $("#code5").html("inOrder(right)");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 10: // preorder traversal
              $("#code1").html("if this == null"); //code_preorder_1
              $("#code2").html("&nbsp;&nbsp;return"); //code_preorder_2
              $("#code3").html("visit this"); //code_preorder_3
              $("#code4").html("preOrder(left)"); //code_preorder_4
              $("#code5").html("preOrder(right)");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 11: // postorder traversal
              $("#code1").html("if this == null"); //code_postorder_1
              $("#code2").html("&nbsp;&nbsp;return"); //code_postorder_2
              $("#code3").html("postOrder(left)"); //code_postorder_3
              $("#code4").html("postOrder(right)"); //code_postorder_4
              $("#code5").html("visit this");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 12: //Count All
              $("#code1").html("if this == null"); //code_postorder_1
              $("#code2").html("&nbsp;&nbsp;return 0"); //code_postorder_2
              $("#code3").html("cl = countAll(left)"); //code_postorder_3
              $("#code4").html("cr = countAll(right)"); //code_postorder_4
              $("#code5").html("return (cl + cr + 1)");
              $("#code6").html("");
              $("#code7").html("");
              break;
            case 13: //Count Leaf
              $("#code1").html("if this == null"); //code_postorder_1
              $("#code2").html("&nbsp;&nbsp;return 0"); //code_postorder_2
              $("#code3").html("cl = countLeaf(left)"); //code_postorder_3
              $("#code4").html("cr = countLeaf(right)"); //code_postorder_4
              $("#code5").html("if left == null and right == null");
              $("#code6").html("&nbsp;&nbsp;return (1 + cl + cr)");
              $("#code7").html("return (cl + cr)");
              break;
            case 14: //Count Medium
              $("#code1").html("call = countAll(root)"); //code_postorder_1
              $("#code2").html("if ca < 3 return 0"); //code_postorder_2
              $("#code3").html("cleaf = countLeaf(root)"); //code_postorder_3
              $("#code4").html("return (call - cleaf - 1)"); //code_postorder_4
              $("#code5").html("");
              $("#code6").html("");
              $("#code7").html("");
              break;
          }
        }
      };

      // BSTaction.js
      var actionsWidth = 270;
      var statusCodetraceWidth = 420;

      // local
      var bw, gw;

      $(function () {
        $("#play").hide();
        bw = new BST();
        gw = bw.getGraphWidget();
        bw.generateRandom();

        var bstMode = getQueryVariable("mode");
        if (bstMode.length > 0) $("#title-" + bstMode).click();
        var createBST = getQueryVariable("create");
        if (createBST.length > 0) {
          var newBST = createBST.split(",");
          bw.generate(newBST);
        }
      });

      function closeCreate() {
        closeAction("create");
      }

      // title changing
      $("#title-BST").click(function () {
        if (isPlaying) stop();
        showActionsPanel();
        showStatusPanel();
        showCodetracePanel();
      });

      function empty() {
        if (isPlaying) stop();
        setTimeout(function () {
          if (bw.generateEmpty()) {
            $("#progress-bar").slider("option", "max", 0);
            //closeCreate();
            isPlaying = false;
          }
        }, 500);
      }

      function example(id) {
        if (isPlaying) stop();
        setTimeout(function () {
          if (bw.generateExample(id)) {
            $("#progress-bar").slider("option", "max", 0);
            //closeCreate();
            isPlaying = false;
          }
        }, 500);
      }

      function random() {
        if (isPlaying) stop();
        setTimeout(function () {
          if (bw.generateRandom()) {
            $("#progress-bar").slider("option", "max", 0);
            //closeCreate();
            isPlaying = false;
          }
        }, 500);
      }

      function skewed(side) {
        if (isPlaying) stop();
        setTimeout(function () {
          if (bw.generateSkewed(side)) {
            $("#progress-bar").slider("option", "max", 0);
            //closeCreate();
            isPlaying = false;
          }
        }, 500);
      }

      function findMinMax(isMin, callback) {
        if (isPlaying) stop();
        commonAction(
          bw.findMinMax(isMin, callback),
          isMin ? "Find Minimum" : "Find Maximum"
        );
      }

      function searchVertex(callback) {
        if (isPlaying) stop();
        var input = $("#v-search").val();
        commonAction(bw.search(input, callback), "Search " + input);
        setTimeout(function () {
          if (Math.random() >= 0.5)
            $("#v-search").val(bw.getRandomInBST()); // 50% an existing value
          else $("#v-search").val(bw.getRandomNotInBST()); // 50% a NON existing value
        }, 500);
      }

      function insertVertex(callback) {
        if (isPlaying) stop();
        var input = $("#v-insert").val();
        commonAction(
          bw.insertArr(input.split(","), callback),
          "Insert " + input
        );
        setTimeout(function () {
          $("#v-insert").val(bw.getRandomNotInBST());
        }, 500); // randomized for next click, a NON existing value in BST
      }

      function removeVertex(callback) {
        if (isPlaying) stop();
        var input = $("#v-remove").val();
        commonAction(
          bw.removeArr(input.split(","), callback),
          "Remove " + input
        );
        setTimeout(function () {
          $("#v-remove").val(bw.getRandomInBST());
        }, 500); // randomized for next click, an existing value in BST
      }

      function predsucc(isPred, callback) {
        if (isPlaying) stop();
        var input = $("#v-predsucc").val();
        commonAction(
          bw.findPredSucc(input.split(","), isPred, callback),
          (isPred ? "Predecessor(" : "Successor(") + input + ")"
        );
        setTimeout(function () {
          $("#v-predsucc").val(bw.getRandomInBST());
        }, 500);
      }

      function inorderTraversal(callback) {
        if (isPlaying) stop();
        commonAction(bw.inorderTraversal(callback), "Inorder Traversal");
      }

      function preorderTraversal(callback) {
        if (isPlaying) stop();
        commonAction(bw.preorderTraversal(callback), "Preorder Traversal");
      }

      function postorderTraversal(callback) {
        if (isPlaying) stop();
        commonAction(bw.postorderTraversal(callback), "Postorder Traversal");
      }

      function countAll(callback) {
        if (isPlaying) stop();
        commonAction(bw.countAll(callback), "Count All Nodes");
      }

      function countLeaf(callback) {
        if (isPlaying) stop();
        commonAction(bw.countLeaf(callback), "Count Leaves");
      }

      function countMedium(callback) {
        if (isPlaying) stop();
        commonAction(bw.countMedium(callback), "Count Medium Nodes");
      }
      // Implement these functions in each visualisation
      var userGraph = {
        vl: {},
        el: {},
      };
    </script>
  </body>
</html>
